<!DOCTYPE html>
<html>
<head>
<style>
*{box-sizing:border-box;margin:0;padding:0}
body{font-family:'Inter',system-ui,sans-serif;background:var(--figma-color-bg,#fff);color:var(--figma-color-text,#1a1a1a);padding:16px;font-size:13px}

/* Header */
.header-row{display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:12px}
h1{font-size:16px;font-weight:700;letter-spacing:-0.02em}
.subtitle{color:var(--figma-color-text-secondary,#666);font-size:12px;margin-top:2px}
.sync-status{display:flex;flex-direction:column;align-items:flex-end;gap:4px}
.sync-badge{display:inline-flex;align-items:center;gap:6px;padding:5px 12px;border-radius:20px;font-size:11px;font-weight:600;background:var(--figma-color-bg-secondary,#f0f0f0);color:var(--figma-color-text-secondary,#666);transition:all .3s}
.sync-badge.synced{background:#e6f9f1;color:#008f5d}
.sync-badge.syncing{background:#fff3e0;color:#b57a00}
.sync-dot{width:7px;height:7px;border-radius:50%;background:currentColor;flex-shrink:0}
.sync-badge.syncing .sync-dot{animation:pulse .8s ease-in-out infinite}
@keyframes pulse{0%,100%{opacity:1;transform:scale(1)}50%{opacity:.4;transform:scale(.7)}}
.last-updated{font-size:10px;color:var(--figma-color-text-tertiary,#aaa);text-align:right}

/* Main section toggle */
.main-tabs{display:flex;gap:4px;margin-bottom:12px;background:var(--figma-color-bg-secondary,#f0f0f0);border-radius:10px;padding:3px}
.main-tab{flex:1;padding:9px 12px;border-radius:8px;border:none;font-size:13px;font-weight:700;cursor:pointer;background:transparent;color:var(--figma-color-text-secondary,#888);transition:all .2s;text-align:center;display:flex;align-items:center;justify-content:center;gap:6px;letter-spacing:-0.01em}
.main-tab:hover{color:var(--figma-color-text,#333)}
.main-tab.active{background:var(--figma-color-bg,#fff);color:var(--figma-color-text,#1a1a1a);box-shadow:0 1px 3px rgba(0,0,0,.08)}
.main-tab .badge{font-size:10px;padding:2px 7px;border-radius:10px;font-weight:700;background:var(--figma-color-bg-secondary,#e8e8e8);color:var(--figma-color-text-secondary,#888)}
.main-tab.active .badge{background:#7a1c29;color:#fff}

/* Stats */
.stats{display:flex;gap:6px;margin-bottom:12px;flex-wrap:wrap}
.stat{background:var(--figma-color-bg-secondary,#f5f5f5);border-radius:8px;padding:8px 12px;flex:1;min-width:70px;text-align:center;position:relative;transition:background .3s}
.stat.changed{background:#fff8e6}
.stat-number{font-size:18px;font-weight:700;color:var(--figma-color-text,#1a1a1a)}
.stat.changed .stat-number{color:#b57a00}
.stat-label{font-size:10px;color:var(--figma-color-text-secondary,#888);margin-top:1px;text-transform:uppercase;letter-spacing:.05em}
.stat-diff{position:absolute;top:3px;right:5px;font-size:9px;font-weight:700;color:#008f5d;opacity:0;transition:opacity .3s}
.stat-diff.visible{opacity:1}
.stat-diff.negative{color:#d93025}

/* Collection picker (Variables section) */
.collections-panel{margin-bottom:12px;border:1px solid var(--figma-color-border,#e0e0e0);border-radius:10px;overflow:hidden}
.collections-header{display:flex;justify-content:space-between;align-items:center;padding:10px 14px;background:var(--figma-color-bg-secondary,#f8f8f8);border-bottom:1px solid var(--figma-color-border,#e8e8e8);font-size:12px;font-weight:700;color:var(--figma-color-text-secondary,#666);text-transform:uppercase;letter-spacing:.04em}
.collections-header button{font-size:11px;padding:3px 10px;border-radius:6px;border:none;background:var(--figma-color-bg,#fff);color:var(--figma-color-text-secondary,#888);cursor:pointer;font-weight:600}
.collections-header button:hover{color:var(--figma-color-text,#333)}
.collection-item{display:flex;align-items:center;gap:10px;padding:10px 14px;border-bottom:1px solid var(--figma-color-border,#f0f0f0);transition:background .15s}
.collection-item:last-child{border-bottom:none}
.collection-item:hover{background:var(--figma-color-bg-secondary,#fafafa)}
.collection-item input[type="checkbox"]{width:16px;height:16px;accent-color:#7a1c29;cursor:pointer;flex-shrink:0}
.collection-info{flex:1;min-width:0}
.collection-name{font-size:13px;font-weight:600;color:var(--figma-color-text,#1a1a1a)}
.collection-meta{font-size:11px;color:var(--figma-color-text-tertiary,#aaa);margin-top:2px;display:flex;gap:8px}
.collection-meta span{display:inline-flex;align-items:center;gap:3px}

/* Style groups accordion */
.sg-toggle{display:flex;align-items:center;gap:8px;padding:10px 14px;cursor:pointer;background:var(--figma-color-bg-secondary,#f8f8f8);border-bottom:1px solid var(--figma-color-border,#e8e8e8);user-select:none}
.sg-toggle:hover{background:var(--figma-color-bg-hover,#efefef)}
.sg-arrow{font-size:10px;color:var(--figma-color-text-tertiary,#aaa);transition:transform .25s;flex-shrink:0;width:10px}
.sg-arrow.open{transform:rotate(90deg)}
.sg-title{font-size:12px;font-weight:700;color:var(--figma-color-text-secondary,#666);text-transform:uppercase;letter-spacing:.04em;flex:1}
.sg-count{font-size:10px;padding:2px 8px;border-radius:10px;font-weight:600;background:var(--figma-color-bg,#fff);color:var(--figma-color-text-secondary,#888)}
.sg-toggle button{font-size:11px;padding:3px 10px;border-radius:6px;border:none;background:var(--figma-color-bg,#fff);color:var(--figma-color-text-secondary,#888);cursor:pointer;font-weight:600}
.sg-toggle button:hover{color:var(--figma-color-text,#333)}
.sg-chips{display:flex;gap:4px;flex-wrap:wrap;padding:8px 14px}
.sg-chips:empty{display:none}
.sg-chip{display:inline-flex;align-items:center;gap:3px;padding:3px 9px;border-radius:12px;font-size:11px;font-weight:600;background:#7a1c29;color:#fff;white-space:nowrap;transition:opacity .15s}
.sg-chip-x{cursor:pointer;opacity:.6;font-size:13px;line-height:1;padding:0 1px 0 2px}
.sg-chip-x:hover{opacity:1}
.sg-body{max-height:0;overflow:hidden;transition:max-height .25s ease-in}
.sg-body.open{max-height:240px;overflow-y:auto;transition:max-height .3s ease-out}

/* Mode selector */
.mode-selector{margin-bottom:12px;display:flex;gap:4px;flex-wrap:wrap}
.mode-chip{padding:5px 14px;border-radius:20px;border:1.5px solid var(--figma-color-border,#ddd);font-size:12px;font-weight:600;cursor:pointer;background:transparent;color:var(--figma-color-text-secondary,#888);transition:all .2s}
.mode-chip:hover{border-color:var(--figma-color-text-secondary,#888)}
.mode-chip.active{background:#7a1c29;color:#fff;border-color:#7a1c29}

/* Format tabs */
.format-tabs{display:flex;gap:3px;margin-bottom:10px;background:var(--figma-color-bg-secondary,#f0f0f0);border-radius:10px;padding:3px}
.format-tab{flex:1;padding:6px 6px;border-radius:7px;border:none;font-size:11px;font-weight:600;cursor:pointer;background:transparent;color:var(--figma-color-text-secondary,#888);transition:all .2s;text-align:center}
.format-tab:hover{color:var(--figma-color-text,#333)}
.format-tab.active{background:var(--figma-color-bg,#fff);color:var(--figma-color-text,#1a1a1a);box-shadow:0 1px 3px rgba(0,0,0,.08)}

/* Actions */
.actions{display:flex;gap:6px;margin-bottom:8px}
button.btn{padding:7px 14px;border-radius:8px;border:none;font-size:12px;font-weight:600;cursor:pointer;transition:all .2s;flex:1;display:flex;align-items:center;justify-content:center;gap:5px}
button.btn:hover{opacity:.85}
button.btn:disabled{opacity:.4;cursor:not-allowed}
.btn-sync{background:#1a1a1a;color:#fff}
.btn-sync:hover:not(:disabled){background:#333}
.btn-sync.syncing{background:#b57a00;pointer-events:none}
.btn-sync svg{width:13px;height:13px}
.btn-sync.syncing svg{animation:spin .6s linear infinite}
@keyframes spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}
.btn-primary{background:#7a1c29;color:#fff}
.btn-secondary{background:var(--figma-color-bg-secondary,#eee);color:var(--figma-color-text,#333)}
.btn-close{background:transparent;color:var(--figma-color-text-secondary,#888);flex:0;padding:7px 10px}
.btn-docs{background:#1E293B;color:#fff;width:100%;margin-bottom:12px;padding:10px 16px;font-size:13px;border-radius:8px;border:none;font-weight:700;cursor:pointer;transition:all .2s;letter-spacing:.02em}
.btn-docs:hover:not(:disabled){background:#334155}
.btn-docs:disabled{opacity:.35;cursor:not-allowed}
.btn-docs.generating{background:#b57a00;pointer-events:none}

/* Output — code preview */
#output{width:100%;height:calc(100vh - 400px);min-height:120px;border-radius:10px;overflow:auto;background:#1e1e2e;border:1px solid rgba(255,255,255,.08);position:relative}
#output pre{margin:0;padding:14px 16px;counter-reset:line}
#output code{font-family:'SF Mono','Fira Code','Cascadia Code',monospace;font-size:11px;line-height:1.65;color:#cdd6f4;display:block;white-space:pre;tab-size:2}
/* Line numbers */
.code-line{display:block}
.code-line::before{counter-increment:line;content:counter(line);display:inline-block;width:32px;margin-right:14px;text-align:right;color:rgba(205,214,244,.2);font-size:10px;user-select:none;-webkit-user-select:none}
/* Syntax theme — Catppuccin Mocha inspired */
.hl-key{color:#89b4fa}
.hl-str{color:#a6e3a1}
.hl-num{color:#fab387}
.hl-bool{color:#cba6f7}
.hl-null{color:#f38ba8}
.hl-brace{color:#9399b2}
.hl-colon{color:#9399b2}
.hl-comma{color:#6c7086}
.hl-comment{color:#6c7086;font-style:italic}
.hl-prop{color:#89dceb}
.hl-val{color:#a6e3a1}
.hl-selector{color:#f5c2e7}
.hl-unit{color:#fab387}
.hl-keyword{color:#cba6f7;font-weight:600}
.hl-type{color:#89dceb}
.hl-func{color:#f9e2af}
.hl-annotation{color:#f5c2e7}
.hl-var{color:#cdd6f4}
.hl-operator{color:#89b4fa}
.file-hint{margin-top:4px;font-size:11px;color:var(--figma-color-text-tertiary,#aaa);text-align:right}

/* Sections show/hide */
.section{display:none}
.section.active{display:block}

/* Toast */
.toast{position:fixed;bottom:16px;left:50%;transform:translateX(-50%);background:#1a1a1a;color:#fff;padding:8px 20px;border-radius:20px;font-size:12px;font-weight:600;opacity:0;transition:opacity .3s;pointer-events:none;z-index:10}
.toast.visible{opacity:1}

/* Empty state */
.empty-state{text-align:center;padding:32px 16px;color:var(--figma-color-text-tertiary,#aaa)}
.empty-state .empty-icon{font-size:32px;margin-bottom:8px;opacity:.5}
.empty-state p{font-size:13px;line-height:1.5}

/* Mini mode */
.mini-bar{display:none;align-items:center;justify-content:space-between;padding:10px 16px;height:44px}
.mini-status{display:flex;align-items:center;gap:8px;font-size:13px;font-weight:600;color:var(--figma-color-text,#1a1a1a)}
.mini-dot{width:8px;height:8px;border-radius:50%;background:#008f5d;flex-shrink:0}
.mini-dot.inactive{background:var(--figma-color-text-tertiary,#aaa)}
.mini-actions{display:flex;align-items:center;gap:10px}
.mini-updated{font-size:11px;color:var(--figma-color-text-tertiary,#aaa);font-weight:600}
.mini-expand{background:none;border:1px solid var(--figma-color-border,#ddd);border-radius:6px;padding:4px 10px;cursor:pointer;font-size:13px;color:var(--figma-color-text-secondary,#666);font-weight:600}
.mini-expand:hover{background:var(--figma-color-bg-secondary,#f0f0f0)}
body.minimized .header-row,body.minimized .main-tabs,body.minimized .section,body.minimized .format-tabs,body.minimized .actions,body.minimized #output,body.minimized .file-hint,body.minimized .toast{display:none!important}
body.minimized{padding:0}
body.minimized .mini-bar{display:flex}
.btn-minimize{background:none;border:1px solid var(--figma-color-border,#ddd);border-radius:6px;width:28px;height:28px;cursor:pointer;font-size:18px;line-height:1;color:var(--figma-color-text-secondary,#888);display:flex;align-items:center;justify-content:center;flex-shrink:0}
.btn-minimize:hover{background:var(--figma-color-bg-secondary,#f0f0f0)}
.live-badge{display:none;align-items:center;gap:5px;padding:4px 10px;border-radius:12px;font-size:11px;font-weight:600;background:#e6f9f1;color:#008f5d}
.live-badge.active{display:inline-flex}
.live-dot{width:6px;height:6px;border-radius:50%;background:#008f5d;animation:livePulse 2s ease-in-out infinite}
@keyframes livePulse{0%,100%{opacity:1}50%{opacity:.4}}

/* Variable groups modal */
.var-modal-overlay{display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.45);z-index:100;align-items:center;justify-content:center}
.var-modal-overlay.open{display:flex}
.var-modal{background:var(--figma-color-bg,#fff);border-radius:12px;width:calc(100% - 32px);max-height:calc(100% - 48px);display:flex;flex-direction:column;box-shadow:0 8px 32px rgba(0,0,0,.25)}
.var-modal-header{display:flex;justify-content:space-between;align-items:center;padding:14px 16px;border-bottom:1px solid var(--figma-color-border,#e0e0e0)}
.var-modal-header h2{font-size:14px;font-weight:700;color:var(--figma-color-text,#1a1a1a)}
.var-modal-header .var-modal-sub{font-size:11px;color:var(--figma-color-text-tertiary,#aaa);margin-top:2px;font-weight:400}
.var-modal-close{background:none;border:none;font-size:20px;cursor:pointer;color:var(--figma-color-text-secondary,#888);padding:0 4px;line-height:1}
.var-modal-close:hover{color:var(--figma-color-text,#333)}
.var-modal-actions{display:flex;align-items:center;gap:8px;padding:8px 16px;border-bottom:1px solid var(--figma-color-border,#e8e8e8)}
.var-modal-actions button{font-size:11px;padding:4px 12px;border-radius:6px;border:none;background:var(--figma-color-bg-secondary,#f0f0f0);color:var(--figma-color-text-secondary,#888);cursor:pointer;font-weight:600}
.var-modal-actions button:hover{color:var(--figma-color-text,#333)}
.var-modal-count{font-size:11px;color:var(--figma-color-text-tertiary,#aaa);margin-left:auto;font-weight:600}
.var-modal-body{flex:1;overflow-y:auto;padding:4px 0;max-height:340px}
.var-modal-item{display:flex;align-items:center;gap:10px;padding:8px 16px;transition:background .15s;cursor:pointer}
.var-modal-item:hover{background:var(--figma-color-bg-secondary,#fafafa)}
.var-modal-item input{width:16px;height:16px;accent-color:#7a1c29;cursor:pointer;flex-shrink:0}
.var-modal-item-name{font-size:13px;font-weight:600;color:var(--figma-color-text,#1a1a1a);flex:1}
.var-modal-item-count{font-size:12px;color:var(--figma-color-text-tertiary,#aaa);font-weight:700;min-width:32px;text-align:right}
.var-modal-footer{display:flex;justify-content:flex-end;gap:8px;padding:12px 16px;border-top:1px solid var(--figma-color-border,#e0e0e0)}
.var-modal-footer .btn{flex:0;padding:8px 20px}
.var-modal-group{border-bottom:1px solid var(--figma-color-border,#f0f0f0)}
.var-modal-group:last-child{border-bottom:none}
.var-expand{width:20px;height:20px;display:inline-flex;align-items:center;justify-content:center;font-size:10px;color:var(--figma-color-text-tertiary,#aaa);transition:transform .2s;cursor:pointer;flex-shrink:0;border-radius:4px}
.var-expand:hover{background:var(--figma-color-bg-secondary,#f0f0f0);color:var(--figma-color-text,#333)}
.var-expand.open{transform:rotate(90deg)}
.var-expand.hidden{visibility:hidden;pointer-events:none}
.var-modal-children{display:none}
.var-modal-children.open{display:block}
.var-modal-item.child{padding-left:54px}
.var-modal-item-sub{font-size:11px;color:var(--figma-color-text-tertiary,#aaa);margin-left:4px;font-weight:400}

/* ═══ Publish to Bitbucket Modal ═══ */
.pub-overlay{display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.5);z-index:200;align-items:center;justify-content:center}
.pub-overlay.open{display:flex}
.pub-modal{background:var(--figma-color-bg,#fff);border-radius:14px;width:calc(100% - 24px);max-height:calc(100% - 32px);display:flex;flex-direction:column;box-shadow:0 12px 40px rgba(0,0,0,.3)}
.pub-header{display:flex;justify-content:space-between;align-items:center;padding:14px 16px;border-bottom:1px solid var(--figma-color-border,#e0e0e0)}
.pub-header h2{font-size:14px;font-weight:700;color:var(--figma-color-text,#1a1a1a)}
.pub-header-sub{font-size:11px;color:var(--figma-color-text-tertiary,#aaa);margin-top:2px;font-weight:400}
.pub-close{background:none;border:none;font-size:20px;cursor:pointer;color:var(--figma-color-text-secondary,#888);padding:0 4px;line-height:1}
.pub-close:hover{color:var(--figma-color-text,#333)}
.pub-body{flex:1;overflow-y:auto;padding:16px}
.pub-footer{display:flex;justify-content:space-between;align-items:center;gap:8px;padding:12px 16px;border-top:1px solid var(--figma-color-border,#e0e0e0)}
.pub-footer .btn{flex:0;padding:8px 20px}

/* Steps indicator */
.pub-steps{display:flex;gap:0;padding:0 16px 0;border-bottom:1px solid var(--figma-color-border,#e8e8e8)}
.pub-step{flex:1;text-align:center;padding:10px 4px 8px;font-size:11px;font-weight:600;color:var(--figma-color-text-tertiary,#aaa);border-bottom:2px solid transparent;transition:all .2s}
.pub-step.active{color:#7a1c29;border-bottom-color:#7a1c29}
.pub-step.done{color:#008f5d;border-bottom-color:#008f5d}
.pub-step-num{display:inline-flex;align-items:center;justify-content:center;width:18px;height:18px;border-radius:50%;font-size:10px;font-weight:700;background:var(--figma-color-bg-secondary,#eee);color:var(--figma-color-text-tertiary,#aaa);margin-right:4px;vertical-align:middle}
.pub-step.active .pub-step-num{background:#7a1c29;color:#fff}
.pub-step.done .pub-step-num{background:#008f5d;color:#fff}

/* Form elements */
.pub-section{margin-bottom:16px}
.pub-section-title{font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:.04em;color:var(--figma-color-text-secondary,#666);margin-bottom:8px}

/* Selection summary in publish modal */
.pub-sel-group{margin-bottom:8px}
.pub-sel-group:last-child{margin-bottom:0}
.pub-sel-label{font-size:11px;font-weight:600;color:var(--figma-color-text-tertiary,#999);margin-bottom:5px;text-transform:uppercase;letter-spacing:.03em}
.pub-sel-chips{display:flex;gap:4px;flex-wrap:wrap}
.pub-sel-chip{display:inline-flex;align-items:center;gap:4px;padding:4px 10px;border-radius:14px;font-size:11px;font-weight:600;background:#7a1c29;color:#fff;white-space:nowrap}
.pub-sel-chip .pub-sel-count{font-size:10px;opacity:.75;font-weight:400}
.pub-sel-all{font-size:12px;color:var(--figma-color-text-secondary,#888);font-style:italic}
.pub-sel-none{font-size:12px;color:#d93025;font-weight:600}
.pub-row{margin-bottom:10px}
.pub-label{display:block;font-size:12px;font-weight:600;color:var(--figma-color-text,#1a1a1a);margin-bottom:4px}
.pub-input{width:100%;padding:8px 10px;border:1px solid var(--figma-color-border,#ddd);border-radius:6px;font-size:12px;font-family:inherit;background:var(--figma-color-bg,#fff);color:var(--figma-color-text,#1a1a1a);transition:border-color .2s}
.pub-input:focus{outline:none;border-color:#7a1c29}
.pub-input::placeholder{color:var(--figma-color-text-tertiary,#bbb)}
textarea.pub-input{resize:vertical;min-height:60px;font-family:'SF Mono','Fira Code',monospace;font-size:11px;line-height:1.4}
.pub-input-row{display:flex;gap:8px}
.pub-input-row .pub-row{flex:1}
.pub-pw-wrap{position:relative}
.pub-pw-wrap .pub-input{padding-right:36px}
.pub-pw-toggle{position:absolute;right:8px;top:50%;transform:translateY(-50%);background:none;border:none;cursor:pointer;font-size:14px;color:var(--figma-color-text-tertiary,#aaa);padding:2px}
.pub-pw-toggle:hover{color:var(--figma-color-text,#333)}
.pub-cred-actions{display:flex;gap:6px;margin-top:6px}
.pub-cred-actions button{font-size:11px;padding:4px 12px;border-radius:6px;border:none;cursor:pointer;font-weight:600}
.pub-btn-save{background:#e6f9f1;color:#008f5d}
.pub-btn-save:hover{background:#ccf2e1}
.pub-btn-clear{background:var(--figma-color-bg-secondary,#f0f0f0);color:var(--figma-color-text-secondary,#888)}
.pub-btn-clear:hover{color:var(--figma-color-text,#333)}
.pub-btn-check{background:#1E3A5F;color:#fff}
.pub-btn-check:hover{background:#2a4f7a}
.pub-btn-check:disabled{opacity:.5;cursor:not-allowed}
.pub-btn-check.checking{background:#b57a00;pointer-events:none}
.pub-conn-status{margin-top:8px;padding:0;font-size:12px;font-weight:600;border-radius:8px;transition:all .3s;overflow:hidden;max-height:0}
.pub-conn-status.visible{padding:10px 12px;max-height:80px}
.pub-conn-status.success{background:#e6f9f1;color:#008f5d}
.pub-conn-status.error{background:#fce8e6;color:#d93025}
.pub-conn-status.checking{background:#fff3e0;color:#b57a00}

/* Collapsible credentials */
.pub-creds-header{display:flex;align-items:center;gap:8px;padding:10px 0;cursor:pointer;user-select:none}
.pub-creds-header:hover .pub-creds-toggle{color:var(--figma-color-text,#333)}
.pub-creds-dot{width:8px;height:8px;border-radius:50%;flex-shrink:0}
.pub-creds-dot.connected{background:#008f5d}
.pub-creds-dot.disconnected{background:var(--figma-color-text-tertiary,#aaa)}
.pub-creds-summary{flex:1;font-size:12px;font-weight:600;color:var(--figma-color-text,#1a1a1a)}
.pub-creds-summary span{color:var(--figma-color-text-secondary,#888);font-weight:400}
.pub-creds-toggle{font-size:11px;padding:4px 10px;border-radius:6px;border:none;background:var(--figma-color-bg-secondary,#f0f0f0);color:var(--figma-color-text-secondary,#888);cursor:pointer;font-weight:600}
.pub-creds-toggle:hover{color:var(--figma-color-text,#333)}
.pub-creds-body{max-height:0;overflow:hidden;transition:max-height .25s ease-in}
.pub-creds-body.open{max-height:400px;overflow:visible;transition:max-height .3s ease-out}

/* Branch selector */
.pub-branch-section{margin-bottom:10px}
.pub-branch-toggle{display:flex;gap:4px;margin-bottom:8px}
.pub-branch-wrap{position:relative}
.pub-branch-selected{display:flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid var(--figma-color-border,#ddd);border-radius:6px;font-size:12px;cursor:pointer;background:var(--figma-color-bg,#fff);transition:border-color .2s}
.pub-branch-selected:hover{border-color:#7a1c29}
.pub-branch-selected .pub-branch-icon{color:var(--figma-color-text-tertiary,#aaa);flex-shrink:0;font-size:14px}
.pub-branch-selected .pub-branch-name{flex:1;color:var(--figma-color-text,#1a1a1a);font-weight:600}
.pub-branch-selected .pub-branch-arrow{color:var(--figma-color-text-tertiary,#aaa);font-size:10px;flex-shrink:0;transition:transform .2s}
.pub-branch-selected .pub-branch-arrow.open{transform:rotate(180deg)}
.pub-branch-dropdown{display:none;position:absolute;top:100%;left:0;right:0;margin-top:4px;background:var(--figma-color-bg,#fff);border:1px solid var(--figma-color-border,#ddd);border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,.15);z-index:50;overflow:hidden}
.pub-branch-dropdown.open{display:block}
.pub-branch-search{width:100%;padding:10px 12px;border:none;border-bottom:1px solid var(--figma-color-border,#e8e8e8);font-size:12px;font-family:inherit;background:var(--figma-color-bg-secondary,#f8f8f8);color:var(--figma-color-text,#1a1a1a);outline:none}
.pub-branch-search::placeholder{color:var(--figma-color-text-tertiary,#bbb)}
.pub-branch-list{max-height:200px;overflow-y:auto}
.pub-branch-item{display:flex;align-items:center;gap:8px;padding:8px 12px;font-size:12px;cursor:pointer;transition:background .1s;border-bottom:1px solid var(--figma-color-border,#f0f0f0)}
.pub-branch-item:last-child{border-bottom:none}
.pub-branch-item:hover{background:var(--figma-color-bg-secondary,#f5f5f5)}
.pub-branch-item.selected{background:#f0e6e8}
.pub-branch-item-name{flex:1;font-weight:600;color:var(--figma-color-text,#1a1a1a)}
.pub-branch-item-date{font-size:10px;color:var(--figma-color-text-tertiary,#aaa);white-space:nowrap}
.pub-branch-item-badge{font-size:9px;padding:2px 6px;border-radius:4px;font-weight:700;background:#e6f9f1;color:#008f5d;text-transform:uppercase;letter-spacing:.03em;flex-shrink:0}
.pub-branch-empty{padding:16px;text-align:center;font-size:12px;color:var(--figma-color-text-tertiary,#aaa)}
.pub-branch-loading{padding:12px;text-align:center;font-size:12px;color:#b57a00}

/* Reviewer picker */
.pub-reviewers-wrap{position:relative}
.pub-reviewer-chips{display:flex;gap:4px;flex-wrap:wrap;margin-bottom:6px}
.pub-reviewer-chips:empty{display:none}
.pub-reviewer-chip{display:inline-flex;align-items:center;gap:3px;padding:3px 9px;border-radius:12px;font-size:11px;font-weight:600;background:#7a1c29;color:#fff;white-space:nowrap;transition:opacity .15s}
.pub-chip-x{cursor:pointer;opacity:.6;font-size:13px;line-height:1;padding:0 1px 0 2px}
.pub-chip-x:hover{opacity:1}
.pub-member-dropdown{display:none;position:absolute;top:100%;left:0;right:0;margin-top:4px;background:var(--figma-color-bg,#fff);border:1px solid var(--figma-color-border,#ddd);border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,.15);z-index:50;overflow:hidden}
.pub-member-dropdown.open{display:block}
.pub-member-search{width:100%;padding:10px 12px;border:none;border-bottom:1px solid var(--figma-color-border,#e8e8e8);font-size:12px;font-family:inherit;background:var(--figma-color-bg-secondary,#f8f8f8);color:var(--figma-color-text,#1a1a1a);outline:none;box-sizing:border-box}
.pub-member-search::placeholder{color:var(--figma-color-text-tertiary,#bbb)}
.pub-member-list{max-height:200px;overflow-y:auto}
.pub-member-item{display:flex;align-items:center;gap:8px;padding:8px 12px;font-size:12px;cursor:pointer;transition:background .1s;border-bottom:1px solid var(--figma-color-border,#f0f0f0)}
.pub-member-item:last-child{border-bottom:none}
.pub-member-item:hover{background:var(--figma-color-bg-secondary,#f5f5f5)}
.pub-member-item.selected{opacity:.5;cursor:default}
.pub-member-avatar{width:24px;height:24px;border-radius:50%;flex-shrink:0;background:var(--figma-color-bg-secondary,#eee);object-fit:cover}
.pub-member-name{flex:1;font-weight:600;color:var(--figma-color-text,#1a1a1a)}
.pub-member-nick{font-size:10px;color:var(--figma-color-text-tertiary,#aaa);white-space:nowrap}
.pub-member-tick{font-size:14px;color:#008f5d;flex-shrink:0}
.pub-member-empty{padding:16px;text-align:center;font-size:12px;color:var(--figma-color-text-tertiary,#aaa)}
.pub-member-group-label{padding:6px 12px;font-size:10px;font-weight:700;text-transform:uppercase;letter-spacing:.04em;color:var(--figma-color-text-tertiary,#aaa);background:var(--figma-color-bg-secondary,#f8f8f8);border-bottom:1px solid var(--figma-color-border,#eee)}
.pub-member-avatar-saved{display:flex;align-items:center;justify-content:center;font-size:14px;color:#b57a00;background:#fff3e0}
.pub-member-remove{font-size:11px;color:var(--figma-color-text-tertiary,#bbb);cursor:pointer;flex-shrink:0;padding:2px 4px;border-radius:4px;transition:all .15s}
.pub-member-remove:hover{color:#cf222e;background:#ffebe9}
.pub-reviewer-input-row{display:flex;gap:4px;align-items:stretch}
.pub-reviewer-input-row .pub-input{flex:1}
.pub-reviewer-add-btn{width:34px;flex-shrink:0;border:1.5px solid var(--figma-color-border,#ddd);border-radius:8px;background:transparent;color:var(--figma-color-text-secondary,#888);font-size:18px;font-weight:600;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .15s}
.pub-reviewer-add-btn:hover{background:#7a1c29;color:#fff;border-color:#7a1c29}
.pub-reviewer-hint{font-size:10px;color:var(--figma-color-text-tertiary,#aaa);margin-top:4px;line-height:1.4}

/* @Mention row */
.pub-mention-row{display:flex;align-items:center;gap:6px;flex-wrap:wrap;margin-top:6px;font-size:11px;color:var(--figma-color-text-secondary,#888)}
.pub-mention-row:empty{display:none}
.pub-mention-label{font-weight:600;color:var(--figma-color-text-tertiary,#aaa)}
.pub-mention-chip{display:inline-flex;align-items:center;padding:2px 8px;border-radius:10px;font-size:11px;font-weight:600;cursor:pointer;background:var(--figma-color-bg-secondary,#f0f0f0);color:var(--figma-color-text,#1a1a1a);border:1px solid var(--figma-color-border,#ddd);transition:all .15s}
.pub-mention-chip:hover{background:#7a1c29;color:#fff;border-color:#7a1c29}
.pub-mention-more{font-size:11px;color:#7a1c29;cursor:pointer;font-weight:600}
.pub-mention-more:hover{text-decoration:underline}

/* Radio group */
.pub-radios{display:flex;gap:6px;flex-wrap:wrap}
.pub-radio{display:inline-flex;align-items:center;gap:5px;padding:6px 14px;border-radius:20px;border:1.5px solid var(--figma-color-border,#ddd);font-size:12px;font-weight:600;cursor:pointer;color:var(--figma-color-text-secondary,#888);transition:all .2s;background:transparent}
.pub-radio:hover{border-color:var(--figma-color-text-secondary,#888)}
.pub-radio.active{background:#7a1c29;color:#fff;border-color:#7a1c29}
.pub-radio input{display:none}

/* Review card */
.pub-review-card{background:var(--figma-color-bg-secondary,#f8f8f8);border-radius:10px;padding:14px;margin-bottom:12px}
.pub-review-row{display:flex;justify-content:space-between;padding:4px 0;font-size:12px}
.pub-review-row span:first-child{color:var(--figma-color-text-secondary,#888);font-weight:600}
.pub-review-row span:last-child{color:var(--figma-color-text,#1a1a1a);font-weight:600;text-align:right;max-width:60%;word-break:break-all}
.pub-preview{max-height:160px;overflow-y:auto;background:var(--figma-color-bg-secondary,#f5f5f5);border:1px solid var(--figma-color-border,#e0e0e0);border-radius:8px;padding:10px;font-family:'SF Mono','Fira Code',monospace;font-size:10px;line-height:1.5;color:var(--figma-color-text,#1a1a1a);white-space:pre-wrap;word-break:break-all}

/* Diff modal */
.pub-diff-overlay{display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.6);z-index:300;align-items:center;justify-content:center}
.pub-diff-overlay.open{display:flex}
.pub-diff-modal{background:var(--figma-color-bg,#fff);border-radius:14px;width:calc(100% - 16px);height:calc(100% - 24px);display:flex;flex-direction:column;box-shadow:0 16px 48px rgba(0,0,0,.35);overflow:hidden}
.pub-diff-modal-header{display:flex;align-items:center;gap:10px;padding:12px 16px;border-bottom:1px solid var(--figma-color-border,#e0e0e0);flex-shrink:0}
.pub-diff-modal-header h3{flex:1;font-size:14px;font-weight:700;color:var(--figma-color-text,#1a1a1a);margin:0}
.pub-diff-modal-header .pub-diff-filepath{font-size:11px;color:var(--figma-color-text-secondary,#888);font-family:'SF Mono','Fira Code',monospace;font-weight:500}
.pub-diff-close{width:28px;height:28px;border-radius:8px;border:none;background:var(--figma-color-bg-secondary,#f0f0f0);color:var(--figma-color-text-secondary,#888);font-size:16px;cursor:pointer;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:all .15s}
.pub-diff-close:hover{background:#7a1c29;color:#fff}
.pub-diff-stats-bar{display:flex;align-items:center;gap:10px;padding:8px 16px;border-bottom:1px solid var(--figma-color-border,#eee);flex-shrink:0;font-size:11px;font-weight:600}
.pub-diff-stat-add{color:#1a7f37}
.pub-diff-stat-del{color:#cf222e}
.pub-diff-stat-blocks{display:flex;gap:1px;align-items:center}
.pub-diff-stat-blocks span{width:8px;height:8px;border-radius:1px}
.pub-diff-stat-blocks .add{background:#1a7f37}
.pub-diff-stat-blocks .del{background:#cf222e}
.pub-diff-stat-label{font-size:11px;color:var(--figma-color-text-tertiary,#aaa);font-weight:500}
.pub-diff-body{flex:1;overflow-y:auto;font-family:'SF Mono','Fira Code',monospace;font-size:11px;line-height:1.7}
.pub-diff-line{display:flex;border-bottom:1px solid rgba(0,0,0,.03)}
.pub-diff-line:last-child{border-bottom:none}
.pub-diff-ln{width:40px;min-width:40px;padding:0 6px;text-align:right;color:rgba(0,0,0,.25);user-select:none;font-size:10px;border-right:1px solid rgba(0,0,0,.05)}
.pub-diff-ln-old{border-right:none}
.pub-diff-code{flex:1;padding:0 10px;white-space:pre-wrap;word-break:break-all}
.pub-diff-line.added{background:#dafbe1}
.pub-diff-line.added .pub-diff-ln{background:#ccffd8;color:rgba(0,0,0,.35)}
.pub-diff-line.added .pub-diff-code{color:#1a7f37}
.pub-diff-line.removed{background:#ffebe9}
.pub-diff-line.removed .pub-diff-ln{background:#ffd7d5;color:rgba(0,0,0,.35)}
.pub-diff-line.removed .pub-diff-code{color:#cf222e}
.pub-diff-line.context{background:transparent}
.pub-diff-line.context .pub-diff-code{color:var(--figma-color-text-secondary,#888)}
.pub-diff-hunk{background:#ddf4ff;color:#0969da;font-weight:600;padding:5px 12px;font-size:10px;border-bottom:1px solid rgba(0,0,0,.05)}
.pub-diff-loading{padding:24px;text-align:center;font-size:12px;color:#b57a00}

/* Code Compare button in review step */
.pub-compare-btn{display:inline-flex;align-items:center;gap:6px;padding:7px 14px;border-radius:8px;border:1.5px solid var(--figma-color-border,#ddd);background:transparent;color:var(--figma-color-text,#1a1a1a);font-size:12px;font-weight:600;cursor:pointer;transition:all .15s;font-family:inherit}
.pub-compare-btn:hover{background:#7a1c29;color:#fff;border-color:#7a1c29}
.pub-compare-btn svg{width:14px;height:14px}
.pub-compare-row{display:flex;align-items:center;justify-content:space-between;margin-top:12px;margin-bottom:6px}

/* Progress steps */
.pub-progress{list-style:none;padding:0}
.pub-progress li{display:flex;align-items:center;gap:10px;padding:10px 0;font-size:13px;font-weight:600;color:var(--figma-color-text-secondary,#888);border-bottom:1px solid var(--figma-color-border,#f0f0f0)}
.pub-progress li:last-child{border-bottom:none}
.pub-progress-icon{width:24px;height:24px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:12px;flex-shrink:0;background:var(--figma-color-bg-secondary,#eee);color:var(--figma-color-text-tertiary,#aaa)}
.pub-progress li.active{color:var(--figma-color-text,#1a1a1a)}
.pub-progress li.active .pub-progress-icon{background:#fff3e0;color:#b57a00;animation:pubPulse 1s ease-in-out infinite}
.pub-progress li.done{color:#008f5d}
.pub-progress li.done .pub-progress-icon{background:#e6f9f1;color:#008f5d}
.pub-progress li.error{color:#d93025}
.pub-progress li.error .pub-progress-icon{background:#fce8e6;color:#d93025}
@keyframes pubPulse{0%,100%{opacity:1}50%{opacity:.5}}
.pub-error-msg{margin-top:8px;padding:10px 12px;background:#fce8e6;border-radius:8px;font-size:12px;color:#d93025;font-weight:500}

/* Done state */
.pub-done{text-align:center;padding:24px 16px}
.pub-done-icon{font-size:48px;margin-bottom:12px}
.pub-done h3{font-size:16px;font-weight:700;color:var(--figma-color-text,#1a1a1a);margin-bottom:6px}
.pub-done p{font-size:12px;color:var(--figma-color-text-secondary,#888);margin-bottom:4px}
.pub-done a{display:inline-block;margin-top:12px;padding:8px 20px;background:#7a1c29;color:#fff;border-radius:8px;text-decoration:none;font-size:12px;font-weight:700;transition:opacity .2s}
.pub-done a:hover{opacity:.85}
.pub-done-branch{margin-top:8px;font-size:11px;color:var(--figma-color-text-tertiary,#aaa)}

/* Publish button in actions bar */
.btn-publish{background:#1E3A5F;color:#fff}
.btn-publish:hover:not(:disabled){background:#2a4f7a}
.btn-publish svg{width:13px;height:13px}
</style>
</head>
<body>

<!-- Mini bar (visible when minimised) -->
<div class="mini-bar" id="mini-bar">
  <div class="mini-status">
    <span class="mini-dot inactive" id="mini-dot"></span>
    <span id="mini-label">No doc</span>
  </div>
  <div class="mini-actions">
    <span class="mini-updated" id="mini-updated"></span>
    <button class="mini-expand" id="btn-expand" type="button" title="Expand">&#x2197;</button>
  </div>
</div>

<!-- Header -->
<div class="header-row">
  <div>
    <h1>DS Extractor <span style="font-weight:400;font-size:12px;color:var(--figma-color-text-tertiary,#aaa)">v2</span></h1>
    <p class="subtitle" id="subtitle">Loading...</p>
  </div>
  <div class="sync-status">
    <div class="live-badge" id="live-badge"><span class="live-dot"></span> Doc live</div>
    <div class="sync-badge" id="sync-badge"><span class="sync-dot"></span><span id="sync-label">Waiting</span></div>
    <div class="last-updated" id="last-updated"></div>
    <button class="btn-minimize" id="btn-minimize" type="button" title="Minimise">&#x2212;</button>
  </div>
</div>

<!-- Main section toggle: Styles vs Variables -->
<div class="main-tabs" id="main-tabs">
  <button class="main-tab active" data-section="styles" type="button">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.70226 12.7583C10.0985 12.7584 11.2308 13.8905 11.2308 15.2868V20.2252C11.2303 21.6212 10.0982 22.7535 8.70226 22.7537H3.76384C2.36803 22.7533 1.23577 21.621 1.23535 20.2252V15.2868C1.23535 13.8906 2.36776 12.7586 3.76384 12.7583H8.70226ZM21.8714 21.415H14.0529V19.6503H21.8714V21.415ZM3.76384 14.523C3.34238 14.5233 3.00006 14.8652 3.00006 15.2868V20.2252C3.00048 20.6464 3.34262 20.9886 3.76384 20.989H8.70226C9.12364 20.9888 9.46563 20.6465 9.46605 20.2252V15.2868C9.46605 14.8651 9.12389 14.5231 8.70226 14.523H3.76384ZM21.8714 15.8603H14.0529V14.0956H21.8714V15.8603ZM8.70226 1.23529C10.0985 1.23546 11.2307 2.36754 11.2308 3.76378V8.7022C11.2306 10.0983 10.0984 11.2305 8.70226 11.2307H3.76384C2.36786 11.2303 1.23553 10.0982 1.23535 8.7022V3.76378C1.2354 2.36765 2.36779 1.23565 3.76384 1.23529H8.70226ZM21.8714 9.89338H14.0529V8.12867H21.8714V9.89338ZM3.76384 3C3.34241 3.00036 3.00011 3.34227 3.00006 3.76378V8.7022C3.00023 9.12361 3.34248 9.46563 3.76384 9.46599H8.70226C9.12378 9.46582 9.46588 9.12372 9.46605 8.7022V3.76378C9.466 3.34216 9.12386 3.00017 8.70226 3H3.76384ZM21.8714 4.33731H14.0529V2.57261H21.8714V4.33731Z" fill="currentColor"/></svg>
    Styles <span class="badge" id="badge-styles">0</span>
  </button>
  <button class="main-tab" data-section="variables" type="button">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.756 12.7279C10.1368 12.7283 11.2568 13.848 11.2569 15.2289V20.0832C11.2569 21.4641 10.1368 22.5838 8.756 22.5841H3.90168C2.52061 22.5841 1.40076 21.4643 1.40076 20.0832V15.2289C1.40083 13.8478 2.52064 12.7279 3.90168 12.7279H8.756ZM20.0832 12.7279C21.4643 12.7279 22.5841 13.8478 22.5841 15.2289V20.0832C22.5841 21.4643 21.4643 22.5841 20.0832 22.5841H15.2289C13.848 22.5838 12.728 21.4641 12.728 20.0832V15.2289C12.728 13.848 13.8481 12.7282 15.2289 12.7279H20.0832ZM3.90168 14.4926C3.49526 14.4926 3.16553 14.8225 3.16546 15.2289V20.0832C3.16546 20.4897 3.4952 20.8194 3.90168 20.8194H8.756C9.16219 20.8191 9.49221 20.4895 9.49221 20.0832V15.2289C9.49214 14.8227 9.16214 14.493 8.756 14.4926H3.90168ZM15.2289 14.4926C14.8227 14.4929 14.4927 14.8226 14.4927 15.2289V20.0832C14.4927 20.4895 14.8226 20.8191 15.2289 20.8194H20.0832C20.4897 20.8194 20.8194 20.4897 20.8194 20.0832V15.2289C20.8193 14.8224 20.4896 14.4926 20.0832 14.4926H15.2289ZM8.756 1.39935C10.1367 1.39967 11.2567 2.51959 11.2569 3.90027V8.75459C11.2569 10.1355 10.1368 11.2552 8.756 11.2555H3.90168C2.5206 11.2555 1.40076 10.1357 1.40076 8.75459V3.90027C1.40099 2.51939 2.52074 1.39935 3.90168 1.39935H8.756ZM20.0832 1.39935C21.4642 1.39935 22.5839 2.5194 22.5841 3.90027V8.75459C22.5841 10.1357 21.4643 11.2555 20.0832 11.2555H15.2289C13.848 11.2552 12.728 10.1355 12.728 8.75459V3.90027C12.7282 2.51955 13.8482 1.39962 15.2289 1.39935H20.0832ZM3.90168 3.16406C3.49536 3.16406 3.16569 3.49401 3.16546 3.90027V8.75459C3.16546 9.16105 3.49522 9.4908 3.90168 9.4908H8.756C9.16218 9.49048 9.49221 9.16085 9.49221 8.75459V3.90027C9.49198 3.49421 9.16204 3.16438 8.756 3.16406H3.90168ZM15.2289 3.16406C14.8228 3.16433 14.4929 3.49417 14.4927 3.90027V8.75459C14.4927 9.16089 14.8227 9.49053 15.2289 9.4908H20.0832C20.4897 9.4908 20.8194 9.16106 20.8194 8.75459V3.90027C20.8192 3.494 20.4895 3.16406 20.0832 3.16406H15.2289Z" fill="currentColor"/></svg>
    Variables <span class="badge" id="badge-variables">0</span>
  </button>
</div>

<!-- ══════ STYLES SECTION ══════ -->
<div class="section active" id="section-styles">
  <!-- Style groups accordion -->
  <div class="collections-panel" id="style-groups-panel">
    <div class="sg-toggle" id="sg-toggle">
      <span class="sg-arrow" id="sg-arrow">&#x25B8;</span>
      <span class="sg-title">Style Groups</span>
      <span class="sg-count" id="sg-count">0 / 0</span>
      <button type="button" id="btn-sg-all">All</button>
      <button type="button" id="btn-sg-none">None</button>
    </div>
    <div class="sg-chips" id="sg-chips"></div>
    <div class="sg-body" id="sg-body">
      <div id="style-groups-list"></div>
    </div>
  </div>

  <div class="stats" id="stats-styles">
    <div class="stat" id="stat-paint"><div class="stat-diff" id="diff-paint"></div><div class="stat-number" id="count-paint">0</div><div class="stat-label">Paint</div></div>
    <div class="stat" id="stat-text"><div class="stat-diff" id="diff-text"></div><div class="stat-number" id="count-text">0</div><div class="stat-label">Text</div></div>
    <div class="stat" id="stat-effect"><div class="stat-diff" id="diff-effect"></div><div class="stat-number" id="count-effect">0</div><div class="stat-label">Effect</div></div>
    <div class="stat" id="stat-grid"><div class="stat-diff" id="diff-grid"></div><div class="stat-number" id="count-grid">0</div><div class="stat-label">Grid</div></div>
  </div>

  <button class="btn-docs" id="btn-docs" type="button" disabled>&#x25B8; Generate Documentation</button>
</div>

<!-- ══════ VARIABLES SECTION ══════ -->
<div class="section" id="section-variables">
  <!-- Collection picker -->
  <div class="collections-panel" id="collections-panel">
    <div class="collections-header">
      <span>Collections</span>
      <div>
        <button type="button" id="btn-select-all">All</button>
        <button type="button" id="btn-select-none">None</button>
      </div>
    </div>
    <div id="collections-list"></div>
  </div>

  <!-- Mode selector -->
  <div class="mode-selector" id="mode-selector"></div>

  <!-- Variable stats -->
  <div class="stats" id="stats-variables"></div>

  <button class="btn-docs" id="btn-var-docs" type="button" disabled>&#x25B8; Generate Variables Documentation</button>
</div>

<!-- Format tabs (shared) -->
<div class="format-tabs" id="format-tabs">
  <button class="format-tab active" data-format="figma" type="button">JSON</button>
  <button class="format-tab" data-format="css" type="button">CSS</button>
  <button class="format-tab" data-format="flutter" type="button">Flutter</button>
  <button class="format-tab" data-format="dtcg" type="button">W3C DTCG</button>
</div>

<!-- Action buttons -->
<div class="actions">
  <button class="btn btn-sync" id="btn-sync" type="button">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M16 16h5v5"/></svg>
    <span id="sync-text">Sync</span>
  </button>
  <button class="btn btn-primary" id="btn-copy" type="button" disabled>Copy</button>
  <button class="btn btn-secondary" id="btn-download" type="button" disabled>Download</button>
  <button class="btn btn-publish" id="btn-publish" type="button" disabled>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="18" cy="18" r="3"/><circle cx="6" cy="6" r="3"/><path d="M13 6h3a2 2 0 0 1 2 2v7"/><path d="M6 9v12"/></svg>
    Publish
  </button>
  <button class="btn btn-close" id="btn-close" type="button">&#x2715;</button>
</div>

<div id="output"><pre><code id="output-code"></code></pre></div>
<div class="file-hint" id="file-hint"></div>
<div class="toast" id="toast"></div>

<!-- Variable groups modal -->
<div class="var-modal-overlay" id="var-modal-overlay">
  <div class="var-modal">
    <div class="var-modal-header">
      <div>
        <h2>Select groups to document</h2>
        <div class="var-modal-sub" id="var-modal-sub">Components collection</div>
      </div>
      <button class="var-modal-close" id="var-modal-close" type="button">&times;</button>
    </div>
    <div class="var-modal-actions">
      <button type="button" id="var-modal-all">All</button>
      <button type="button" id="var-modal-none">None</button>
      <span class="var-modal-count" id="var-modal-count">0 / 0</span>
    </div>
    <div class="var-modal-body" id="var-modal-body"></div>
    <div class="var-modal-footer">
      <button class="btn btn-secondary" id="var-modal-cancel" type="button">Cancel</button>
      <button class="btn btn-primary" id="var-modal-generate" type="button">Generate</button>
    </div>
  </div>
</div>

<!-- ══════ PUBLISH TO BITBUCKET MODAL ══════ -->
<div class="pub-overlay" id="pub-overlay">
  <div class="pub-modal">
    <div class="pub-header">
      <div>
        <h2 id="pub-title">Publish to Bitbucket</h2>
        <div class="pub-header-sub" id="pub-header-sub">Create a pull request with your design tokens</div>
      </div>
      <button class="pub-close" id="pub-close" type="button">&times;</button>
    </div>

    <!-- Step indicators -->
    <div class="pub-steps">
      <div class="pub-step active" data-pub-step="1"><span class="pub-step-num">1</span>Settings</div>
      <div class="pub-step" data-pub-step="2"><span class="pub-step-num">2</span>Review</div>
      <div class="pub-step" data-pub-step="3"><span class="pub-step-num">3</span>Publishing</div>
      <div class="pub-step" data-pub-step="4"><span class="pub-step-num">4</span>Done</div>
    </div>

    <div class="pub-body" id="pub-body">
      <!-- Step 1: Settings -->
      <div id="pub-step-1">
        <!-- Collapsible credentials -->
        <div class="pub-section">
          <div class="pub-creds-header" id="pub-creds-header">
            <span class="pub-creds-dot disconnected" id="pub-creds-dot"></span>
            <span class="pub-creds-summary" id="pub-creds-summary">Not connected <span>— configure credentials below</span></span>
            <button class="pub-creds-toggle" id="pub-creds-expand" type="button">Settings</button>
          </div>
          <div class="pub-creds-body open" id="pub-creds-body">
            <div class="pub-input-row">
              <div class="pub-row">
                <label class="pub-label">Workspace</label>
                <input class="pub-input" id="pub-workspace" type="text" placeholder="e.g. my-team">
              </div>
              <div class="pub-row">
                <label class="pub-label">Repository</label>
                <input class="pub-input" id="pub-repo" type="text" placeholder="e.g. design-tokens">
              </div>
            </div>
            <div class="pub-row">
              <label class="pub-label">Email</label>
              <input class="pub-input" id="pub-username" type="email" placeholder="Your Atlassian account email">
            </div>
            <div class="pub-row">
              <label class="pub-label">API Token</label>
              <div class="pub-pw-wrap">
                <input class="pub-input" id="pub-password" type="password" placeholder="Create at Bitbucket > Security > API tokens">
                <button class="pub-pw-toggle" id="pub-pw-toggle" type="button">&#x1F441;</button>
              </div>
            </div>
            <div class="pub-cred-actions">
              <button class="pub-btn-save" id="pub-save-creds" type="button">Save credentials</button>
              <button class="pub-btn-clear" id="pub-clear-creds" type="button">Clear</button>
              <button class="pub-btn-check" id="pub-check-conn" type="button">Check connection</button>
            </div>
            <div class="pub-conn-status" id="pub-conn-status"></div>
          </div>
        </div>

        <div class="pub-section" id="pub-selection-section">
          <div class="pub-section-title">Publishing</div>
          <div id="pub-selection-content"></div>
        </div>

        <div class="pub-section">
          <div class="pub-section-title">Format</div>
          <div class="pub-radios" id="pub-format-radios">
            <label class="pub-radio active"><input type="radio" name="pub-format" value="figma" checked>JSON</label>
            <label class="pub-radio"><input type="radio" name="pub-format" value="css">CSS</label>
            <label class="pub-radio"><input type="radio" name="pub-format" value="flutter">Flutter</label>
            <label class="pub-radio"><input type="radio" name="pub-format" value="dtcg">W3C DTCG</label>
          </div>
        </div>

        <div class="pub-section">
          <div class="pub-section-title">Branch</div>
          <div class="pub-branch-toggle">
            <label class="pub-radio active"><input type="radio" name="pub-branch-mode" value="new" checked>Create new</label>
            <label class="pub-radio"><input type="radio" name="pub-branch-mode" value="existing">Use existing</label>
          </div>
          <!-- Create new mode -->
          <div id="pub-branch-new">
            <div class="pub-row">
              <input class="pub-input" id="pub-branch-name" type="text" placeholder="design-tokens/2026-02-22-styles">
            </div>
          </div>
          <!-- Use existing mode -->
          <div id="pub-branch-existing" style="display:none">
            <div class="pub-branch-wrap">
              <div class="pub-branch-selected" id="pub-branch-trigger">
                <span class="pub-branch-icon">&#x2387;</span>
                <span class="pub-branch-name" id="pub-branch-display">Select a branch...</span>
                <span class="pub-branch-arrow" id="pub-branch-arrow">&#x25BC;</span>
              </div>
              <div class="pub-branch-dropdown" id="pub-branch-dropdown">
                <input class="pub-branch-search" id="pub-branch-search" type="text" placeholder="Filter branches...">
                <div class="pub-branch-list" id="pub-branch-list">
                  <div class="pub-branch-loading">Loading branches...</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="pub-section">
          <div class="pub-section-title">File &amp; PR Details</div>
          <div class="pub-row">
            <label class="pub-label">File path</label>
            <input class="pub-input" id="pub-filepath" type="text" placeholder="ds/tokens/ds-styles.json">
          </div>
          <div class="pub-row">
            <label class="pub-label">PR title</label>
            <input class="pub-input" id="pub-pr-title" type="text" placeholder="AJBY00: Update design tokens">
          </div>
          <div class="pub-row">
            <label class="pub-label">PR description</label>
            <textarea class="pub-input" id="pub-pr-desc" rows="3" placeholder="Updated design tokens exported from Figma"></textarea>
            <div class="pub-mention-row" id="pub-mention-row"></div>
          </div>
          <div class="pub-row" id="pub-reviewers-section">
            <label class="pub-label">Reviewers (optional)</label>
            <div class="pub-reviewers-wrap">
              <div class="pub-reviewer-chips" id="pub-reviewer-chips"></div>
              <div class="pub-reviewer-input-row">
                <input class="pub-input pub-member-search" id="pub-reviewer-search" type="text" placeholder="Search by name, nickname, or UUID...">
                <button class="pub-reviewer-add-btn" id="pub-reviewer-add" type="button" title="Add reviewer manually">+</button>
              </div>
              <div class="pub-member-dropdown" id="pub-member-dropdown">
                <div class="pub-member-list" id="pub-member-list"></div>
              </div>
              <div class="pub-reviewer-hint" id="pub-reviewer-hint">Type a Bitbucket nickname (e.g. <strong>john-smith</strong>) and press <strong>Enter</strong> — the plugin will look up their UUID automatically</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Step 2: Review -->
      <div id="pub-step-2" style="display:none">
        <div class="pub-review-card" id="pub-review-card"></div>
        <div class="pub-compare-row">
          <div class="pub-section-title">File Preview</div>
          <button class="pub-compare-btn" id="pub-open-diff" type="button">
            <svg viewBox="0 0 16 16" fill="currentColor"><path d="M8.75 1.75a.75.75 0 00-1.5 0V5H4a.75.75 0 000 1.5h3.25V9.5a.75.75 0 001.5 0V6.5H12A.75.75 0 0012 5H8.75V1.75z"/><path d="M1.5 13.25a.75.75 0 01.75-.75h11.5a.75.75 0 010 1.5H2.25a.75.75 0 01-.75-.75z"/></svg>
            View Code Compare
          </button>
        </div>
        <div class="pub-preview" id="pub-preview-content"></div>
      </div>

      <!-- Step 3: Publishing -->
      <div id="pub-step-3" style="display:none">
        <ul class="pub-progress" id="pub-progress">
          <li id="pub-prog-connect"><span class="pub-progress-icon">1</span>Connecting to Bitbucket...</li>
          <li id="pub-prog-check"><span class="pub-progress-icon">2</span>Checking main branch...</li>
          <li id="pub-prog-branch"><span class="pub-progress-icon">3</span><span class="pub-prog-label">Creating branch...</span></li>
          <li id="pub-prog-commit"><span class="pub-progress-icon">4</span>Committing file...</li>
          <li id="pub-prog-pr"><span class="pub-progress-icon">5</span>Creating pull request...</li>
        </ul>
        <div class="pub-error-msg" id="pub-error-msg" style="display:none"></div>
      </div>

      <!-- Step 4: Done -->
      <div id="pub-step-4" style="display:none">
        <div class="pub-done">
          <div class="pub-done-icon">&#x2705;</div>
          <h3>Pull Request Created</h3>
          <p id="pub-done-summary"></p>
          <a id="pub-done-link" href="#" target="_blank">Open Pull Request</a>
          <div class="pub-done-branch" id="pub-done-branch"></div>
        </div>
      </div>
    </div>

    <div class="pub-footer" id="pub-footer">
      <button class="btn btn-secondary" id="pub-back" type="button" style="display:none">Back</button>
      <div style="flex:1"></div>
      <button class="btn btn-secondary" id="pub-cancel" type="button">Cancel</button>
      <button class="btn btn-primary" id="pub-next" type="button">Next: Review</button>
    </div>
  </div>
</div>

<!-- Code Compare modal -->
<div class="pub-diff-overlay" id="pub-diff-overlay">
  <div class="pub-diff-modal">
    <div class="pub-diff-modal-header">
      <h3>Code Compare</h3>
      <span class="pub-diff-filepath" id="pub-diff-filepath"></span>
      <button class="pub-diff-close" id="pub-diff-close" type="button">&times;</button>
    </div>
    <div class="pub-diff-stats-bar" id="pub-diff-stats" style="display:none"></div>
    <div class="pub-diff-body" id="pub-diff-content">
      <div class="pub-diff-loading" id="pub-diff-loading">Fetching existing file for comparison...</div>
    </div>
  </div>
</div>

<script>
// ═══════════════════════════════════════
// STATE
// ═══════════════════════════════════════

let stylesData = null;
let variablesData = null;
let currentSection = 'styles';
let currentFormat = 'figma';
let selectedCollections = new Set();
let selectedModes = new Set();    // multi-select modes
let selectedStyleGroups = new Set();
let sgOpen = false;
let allModes = [];
let syncCount = 0;
let prevStylesBreakdown = null;
let lastSyncTime = null;
let timerInterval = null;

// ═══════════════════════════════════════
// HELPERS
// ═══════════════════════════════════════

function toSlug(name) {
  return name.replace(/\//g, '-').replace(/\s+/g, '-').replace(/[^a-zA-Z0-9-]/g, '').toLowerCase();
}
function toPascalCase(str) {
  return str.replace(/[^a-zA-Z0-9]+/g, ' ').trim().split(/\s+/).map(function(w) {
    return w.charAt(0).toUpperCase() + w.slice(1).toLowerCase();
  }).join('');
}
function getFlutterClassName() {
  var fp = document.getElementById('pub-filepath');
  if (fp && fp.value.trim()) {
    var fileName = fp.value.trim().split('/').pop().replace(/\.dart$/i, '');
    var name = toPascalCase(fileName);
    if (name) return name;
  }
  return 'DSStyles';
}
function toCamel(name) {
  const parts = name.replace(/\//g, ' ').replace(/[^a-zA-Z0-9 ]/g, '').trim().split(/\s+/);
  return parts.map((p, i) => i === 0 ? p.toLowerCase() : p.charAt(0).toUpperCase() + p.slice(1).toLowerCase()).join('');
}
function hexToFlutterColor(hex, alpha) {
  const clean = hex.replace('#', '').toUpperCase();
  const a = alpha !== undefined ? Math.round(alpha * 255) : 255;
  return 'Color(0x' + a.toString(16).toUpperCase().padStart(2, '0') + clean + ')';
}
function fontStyleToWeight(style) {
  if (!style) return 400;
  const s = style.toLowerCase();
  if (s.includes('thin') || s.includes('hairline')) return 100;
  if (s.includes('extralight') || s.includes('ultralight')) return 200;
  if (s.includes('light')) return 300;
  if (s.includes('regular') || s.includes('normal') || s === 'roman') return 400;
  if (s.includes('medium')) return 500;
  if (s.includes('semibold') || s.includes('demibold')) return 600;
  if (s.includes('extrabold') || s.includes('ultrabold')) return 800;
  if (s.includes('bold')) return 700;
  if (s.includes('black') || s.includes('heavy')) return 900;
  return 400;
}
function alphaToHex(a) {
  if (a === undefined || a >= 1) return '';
  return Math.round(a * 255).toString(16).padStart(2, '0');
}
function gradientAngleCSS(t) {
  if (!t) return '180deg';
  var deg = 90 + Math.round(Math.atan2(t[1][0], t[0][0]) * 180 / Math.PI);
  if (deg < 0) deg += 360;
  return deg + 'deg';
}
function gradientStopsCSS(stops) {
  return stops.map(function(s) {
    var c = s.color;
    var a = c.a !== undefined ? c.a : 1;
    var col = a < 1 ? 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',' + a.toFixed(2) + ')' : c.hex;
    return col + ' ' + (s.position * 100).toFixed(1) + '%';
  }).join(', ');
}

// ═══════════════════════════════════════
// STYLE GROUP HELPERS
// ═══════════════════════════════════════

function getStyleGroup(name) {
  const idx = name.indexOf('/');
  return idx > 0 ? name.substring(0, idx) : name;
}

function getFilteredStyles() {
  if (!stylesData) return null;
  if (selectedStyleGroups.size === 0) return stylesData;
  return {
    _meta: stylesData._meta,
    paintStyles: stylesData.paintStyles.filter(s => selectedStyleGroups.has(getStyleGroup(s.name))),
    textStyles: stylesData.textStyles.filter(s => selectedStyleGroups.has(getStyleGroup(s.name))),
    effectStyles: stylesData.effectStyles.filter(s => selectedStyleGroups.has(getStyleGroup(s.name))),
    gridStyles: stylesData.gridStyles.filter(s => selectedStyleGroups.has(getStyleGroup(s.name))),
  };
}

function updateStyleGroupChips() {
  const container = document.getElementById('sg-chips');
  const total = document.querySelectorAll('#style-groups-list input[type="checkbox"]').length;
  document.getElementById('sg-count').textContent = selectedStyleGroups.size + ' / ' + total;

  container.innerHTML = '';
  for (const name of [...selectedStyleGroups].sort((a, b) => a.localeCompare(b))) {
    const chip = document.createElement('span');
    chip.className = 'sg-chip';
    chip.innerHTML = name + ' <span class="sg-chip-x" data-group="' + name.replace(/"/g, '&quot;') + '">&times;</span>';
    container.appendChild(chip);
  }
}

function buildStyleGroupsList() {
  const list = document.getElementById('style-groups-list');
  if (!stylesData) { list.innerHTML = ''; updateStyleGroupChips(); return; }

  // Collect all groups with per-type counts
  const groups = new Map();
  const addToGroup = (name, type) => {
    const g = getStyleGroup(name);
    if (!groups.has(g)) groups.set(g, { paint: 0, text: 0, effect: 0, grid: 0 });
    groups.get(g)[type]++;
  };
  for (const s of stylesData.paintStyles) addToGroup(s.name, 'paint');
  for (const s of stylesData.textStyles) addToGroup(s.name, 'text');
  for (const s of stylesData.effectStyles) addToGroup(s.name, 'effect');
  for (const s of stylesData.gridStyles) addToGroup(s.name, 'grid');

  // Select all groups by default
  selectedStyleGroups.clear();
  list.innerHTML = '';

  // Sort groups alphabetically
  const sorted = [...groups.entries()].sort((a, b) => a[0].localeCompare(b[0]));

  for (const [name, counts] of sorted) {
    selectedStyleGroups.add(name);
    const total = counts.paint + counts.text + counts.effect + counts.grid;
    const parts = [];
    if (counts.paint) parts.push(counts.paint + ' paint');
    if (counts.text) parts.push(counts.text + ' text');
    if (counts.effect) parts.push(counts.effect + ' effect');
    if (counts.grid) parts.push(counts.grid + ' grid');

    const div = document.createElement('div');
    div.className = 'collection-item';
    div.innerHTML = '<input type="checkbox" checked data-style-group="' + name.replace(/"/g, '&quot;') + '">' +
      '<div class="collection-info">' +
      '<div class="collection-name">' + name + '</div>' +
      '<div class="collection-meta"><span>' + total + ' style' + (total > 1 ? 's' : '') + '</span><span>' + parts.join(' \u2022 ') + '</span></div>' +
      '</div>';
    list.appendChild(div);
  }

  updateStyleGroupChips();
}

// ═══════════════════════════════════════
// STYLES FORMAT CONVERTERS
// ═══════════════════════════════════════

function formatStylesCSS(data) {
  let o = '/* Styles \u2014 CSS Custom Properties */\n/* ' + data._meta.fileName + ' \u2014 ' + data._meta.exportedAt + ' */\n\n:root {\n';
  if (data.paintStyles.length) {
    o += '  /* Colours */\n';
    for (const s of data.paintStyles) {
      const p = s.paints[0];
      if (p && p.type === 'SOLID' && p.color) {
        const a = p.color.a !== undefined ? p.color.a : 1;
        o += '  --' + toSlug(s.name) + ': ' + (a < 1 ? 'rgba(' + p.color.r + ',' + p.color.g + ',' + p.color.b + ',' + a.toFixed(2) + ')' : p.color.hex) + ';\n';
      } else if (p && p.type && p.type.startsWith('GRADIENT_') && p.gradientStops) {
        var slug = toSlug(s.name);
        var stops = gradientStopsCSS(p.gradientStops);
        if (p.type === 'GRADIENT_LINEAR') o += '  --' + slug + ': linear-gradient(' + gradientAngleCSS(p.gradientTransform) + ', ' + stops + ');\n';
        else if (p.type === 'GRADIENT_RADIAL') o += '  --' + slug + ': radial-gradient(circle, ' + stops + ');\n';
        else if (p.type === 'GRADIENT_ANGULAR') o += '  --' + slug + ': conic-gradient(' + stops + ');\n';
        else if (p.type === 'GRADIENT_DIAMOND') o += '  --' + slug + ': radial-gradient(circle, ' + stops + ');\n';
      }
    }
    o += '\n';
  }
  if (data.textStyles.length) {
    o += '  /* Typography */\n';
    for (const s of data.textStyles) {
      const slug = toSlug(s.name);
      const bv = s.boundVariables || {};
      o += '  --' + slug + '-family: \'' + s.fontFamily + '\', sans-serif;' + (bv.fontFamily ? ' /* ' + bv.fontFamily + ' */' : '') + '\n';
      o += '  --' + slug + '-size: ' + s.fontSize.toFixed(2) + 'px;' + (bv.fontSize ? ' /* ' + bv.fontSize + ' */' : '') + '\n';
      o += '  --' + slug + '-weight: ' + fontStyleToWeight(s.fontStyle) + ';' + (bv.fontStyle ? ' /* ' + bv.fontStyle + ' */' : '') + '\n';
      if (s.lineHeight.unit !== 'AUTO') {
        o += '  --' + slug + '-line-height: ' + (s.lineHeight.unit === 'PERCENT' ? (s.lineHeight.value / 100).toFixed(3) : s.lineHeight.value.toFixed(2) + 'px') + ';' + (bv.lineHeight ? ' /* ' + bv.lineHeight + ' */' : '') + '\n';
      }
      if (bv.letterSpacing) {
        o += '  --' + slug + '-letter-spacing: ' + (s.letterSpacing ? s.letterSpacing.value : 0) + (s.letterSpacing && s.letterSpacing.unit === 'PERCENT' ? '%' : 'px') + '; /* ' + bv.letterSpacing + ' */\n';
      }
    }
    o += '\n';
  }
  if (data.effectStyles.length) {
    o += '  /* Effects */\n';
    for (const s of data.effectStyles) {
      var slug = toSlug(s.name);
      var shadows = s.effects.filter(e => (e.type === 'DROP_SHADOW' || e.type === 'INNER_SHADOW') && e.visible).map(e => {
        const c = e.color;
        return (e.type === 'INNER_SHADOW' ? 'inset ' : '') + (e.offset ? e.offset.x : 0) + 'px ' + (e.offset ? e.offset.y : 0) + 'px ' + (e.radius || 0) + 'px ' + (e.spread || 0) + 'px ' + (c ? 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',' + (c.a !== undefined ? c.a.toFixed(2) : '1') + ')' : 'rgba(0,0,0,0.1)');
      });
      if (shadows.length) o += '  --' + slug + ': ' + shadows.join(', ') + ';\n';
      var bgBlurs = s.effects.filter(e => e.type === 'BACKGROUND_BLUR' && e.visible);
      if (bgBlurs.length) o += '  --' + slug + '-backdrop: blur(' + (bgBlurs[0].radius || 0) + 'px);\n';
      var layerBlurs = s.effects.filter(e => e.type === 'LAYER_BLUR' && e.visible);
      if (layerBlurs.length) o += '  --' + slug + '-blur: blur(' + (layerBlurs[0].radius || 0) + 'px);\n';
    }
  }
  o += '}\n';
  return o;
}

// Helper: get resolved value for a text style property in a given mode
function _getModeValue(s, prop, modeName) {
  if (s.boundVarModes && s.boundVarModes[prop] && s.boundVarModes[prop][modeName]) {
    var v = s.boundVarModes[prop][modeName];
    if (v.type === 'number') return v.value;
    if (v.type === 'string') return v.value;
    if (v.type === 'color') return v;
  }
  return null;
}

// Helper: generate a single text style entry for a given mode (or default)
function _flutterTextStyle(s, modeName) {
  var bv = s.boundVariables || {};
  var fontSize = (modeName ? _getModeValue(s, 'fontSize', modeName) : null) || s.fontSize;
  var lineHeightVal = modeName ? _getModeValue(s, 'lineHeight', modeName) : null;
  var letterSpacingVal = modeName ? _getModeValue(s, 'letterSpacing', modeName) : null;
  var fontWeight = fontStyleToWeight(s.fontStyle);

  var o = '  static const ' + toCamel(s.name) + " = TextStyle(\n";
  o += "    fontFamily: '" + s.fontFamily + "',\n";
  o += '    fontSize: ' + (typeof fontSize === 'number' ? fontSize.toFixed(1) : fontSize) + ',\n';
  o += '    fontWeight: FontWeight.w' + fontWeight + ',\n';
  // Height
  if (lineHeightVal !== null && typeof lineHeightVal === 'number') {
    o += '    height: ' + (lineHeightVal / fontSize).toFixed(3) + ',\n';
  } else if (s.lineHeight.unit !== 'AUTO') {
    o += '    height: ' + (s.lineHeight.unit === 'PERCENT' ? (s.lineHeight.value / 100).toFixed(3) : (s.lineHeight.value / fontSize).toFixed(3)) + ',\n';
  }
  // Letter spacing
  if (letterSpacingVal !== null && typeof letterSpacingVal === 'number') {
    o += '    letterSpacing: ' + letterSpacingVal + ',\n';
  } else if (s.letterSpacing && s.letterSpacing.value) {
    o += '    letterSpacing: ' + s.letterSpacing.value + ',\n';
  }
  o += '  );\n\n';
  return o;
}

// Helper: generate paint style entries
function _flutterPaintStyles(data) {
  var o = '';
  if (!data.paintStyles.length) return o;
  o += '  // Colours\n';
  for (var s of data.paintStyles) {
    var p = s.paints[0];
    if (p && p.type === 'SOLID' && p.color) {
      o += '  static const ' + toCamel(s.name) + ' = ' + hexToFlutterColor(p.color.hex, p.color.a) + ';\n';
    } else if (p && p.type && p.type.startsWith('GRADIENT_') && p.gradientStops) {
      var gType = p.type === 'GRADIENT_RADIAL' ? 'RadialGradient' : p.type === 'GRADIENT_ANGULAR' ? 'SweepGradient' : 'LinearGradient';
      var colors = p.gradientStops.map(function(st) { return hexToFlutterColor(st.color.hex, st.color.a); }).join(', ');
      var gStops = p.gradientStops.map(function(st) { return st.position.toFixed(2); }).join(', ');
      o += '  static const ' + toCamel(s.name) + ' = ' + gType + '(\n';
      o += '    colors: [' + colors + '],\n';
      o += '    stops: [' + gStops + '],\n';
      o += '  );\n\n';
    }
  }
  o += '\n';
  return o;
}

// Helper: generate effect style entries
function _flutterEffectStyles(data) {
  var o = '';
  if (!data.effectStyles.length) return o;
  o += '  // Effects\n';
  for (var s of data.effectStyles) {
    var name = toCamel(s.name);
    var sh = s.effects.filter(function(e) { return (e.type === 'DROP_SHADOW' || e.type === 'INNER_SHADOW') && e.visible; });
    if (sh.length) { o += '  static const ' + name + ' = [\n'; for (var e of sh) { var c = e.color; o += '    BoxShadow(color: ' + (c ? hexToFlutterColor(c.hex, c.a) : 'Color(0x1A000000)') + ', offset: Offset(' + (e.offset ? e.offset.x : 0) + ', ' + (e.offset ? e.offset.y : 0) + '), blurRadius: ' + (e.radius || 0) + ', spreadRadius: ' + (e.spread || 0) + '),\n'; } o += '  ];\n\n'; }
    var bgBlurs = s.effects.filter(function(e) { return e.type === 'BACKGROUND_BLUR' && e.visible; });
    if (bgBlurs.length) o += '  static final ' + name + 'Backdrop = ImageFilter.blur(sigmaX: ' + (bgBlurs[0].radius || 0).toFixed(1) + ', sigmaY: ' + (bgBlurs[0].radius || 0).toFixed(1) + ');\n\n';
    var layerBlurs = s.effects.filter(function(e) { return e.type === 'LAYER_BLUR' && e.visible; });
    if (layerBlurs.length) o += '  static final ' + name + 'Blur = ImageFilter.blur(sigmaX: ' + (layerBlurs[0].radius || 0).toFixed(1) + ', sigmaY: ' + (layerBlurs[0].radius || 0).toFixed(1) + ');\n\n';
  }
  return o;
}

function formatStylesFlutter(data) {
  var cls = getFlutterClassName();
  var o = "import 'package:flutter/material.dart';\n\n";

  // Detect if text styles have multi-mode bound variables
  var modeNames = null;
  if (data.textStyles.length) {
    for (var ts of data.textStyles) {
      if (ts.modeNames && ts.modeNames.length > 1) {
        modeNames = ts.modeNames;
        break;
      }
    }
  }

  if (modeNames && modeNames.length > 1) {
    // ── Multi-mode: generate one class per mode ──
    for (var mi = 0; mi < modeNames.length; mi++) {
      var mode = modeNames[mi];
      var modeCls = cls + toPascalCase(mode);
      o += 'abstract class ' + modeCls + ' {\n  ' + modeCls + '._();\n\n';
      // Paint styles (same across modes — no bound variable modes for paint yet)
      if (mi === 0) {
        o += _flutterPaintStyles(data);
      }
      // Typography per mode
      if (data.textStyles.length) {
        o += '  // Typography \u2014 ' + mode + '\n';
        for (var s of data.textStyles) {
          o += _flutterTextStyle(s, mode);
        }
      }
      // Effects (same across modes)
      if (mi === 0) {
        o += _flutterEffectStyles(data);
      }
      o += '}\n\n';
    }
  } else {
    // ── Single-mode: original behaviour ──
    o += 'abstract class ' + cls + ' {\n  ' + cls + '._();\n\n';
    o += _flutterPaintStyles(data);
    if (data.textStyles.length) {
      o += '  // Typography\n';
      for (var s of data.textStyles) {
        o += _flutterTextStyle(s, null);
      }
    }
    o += _flutterEffectStyles(data);
    o += '}\n';
  }
  return o;
}

function formatStylesDTCG(data) {
  const t = { $description: 'Styles from ' + data._meta.fileName };
  if (data.paintStyles.length) {
    t.color = {};
    for (const s of data.paintStyles) {
      const p = s.paints[0];
      if (p && p.type === 'SOLID' && p.color) {
        setNested(t.color, s.name, { $type: 'color', $value: p.color.hex + alphaToHex(p.color.a) });
      } else if (p && p.type && p.type.startsWith('GRADIENT_') && p.gradientStops) {
        var gType = p.type.replace('GRADIENT_', '').toLowerCase();
        setNested(t.color, s.name, { $type: 'gradient', $value: { type: gType, angle: gradientAngleCSS(p.gradientTransform), stops: p.gradientStops.map(function(st) { return { color: st.color.hex + alphaToHex(st.color.a), position: st.position }; }) } });
      }
    }
  }
  if (data.textStyles.length) { t.typography = {}; for (const s of data.textStyles) { const lh = s.lineHeight.unit === 'AUTO' ? 'auto' : s.lineHeight.unit === 'PERCENT' ? s.lineHeight.value + '%' : s.lineHeight.value.toFixed(2) + 'px'; const bv = s.boundVariables || {}; const tvObj = { $type: 'typography', $value: { fontFamily: s.fontFamily, fontWeight: fontStyleToWeight(s.fontStyle), fontSize: s.fontSize.toFixed(2) + 'px', lineHeight: lh } }; if (Object.keys(bv).length) { tvObj.$extensions = { 'com.figma.boundVariables': bv }; } setNested(t.typography, s.name, tvObj); } }
  if (data.effectStyles.length) {
    t.effect = {};
    for (const s of data.effectStyles) {
      var sh = s.effects.filter(e => (e.type === 'DROP_SHADOW' || e.type === 'INNER_SHADOW') && e.visible);
      if (sh.length) { setNested(t.effect, s.name, { $type: 'shadow', $value: sh.map(e => ({ color: (e.color ? e.color.hex + alphaToHex(e.color.a) : '#0000001a'), offsetX: (e.offset ? e.offset.x : 0) + 'px', offsetY: (e.offset ? e.offset.y : 0) + 'px', blur: (e.radius || 0) + 'px', spread: (e.spread || 0) + 'px' })) }); }
      var bgBlurs = s.effects.filter(e => e.type === 'BACKGROUND_BLUR' && e.visible);
      if (bgBlurs.length) { setNested(t.effect, s.name + (sh.length ? '/backdrop-blur' : ''), { $type: 'blur', $value: { type: 'background', radius: (bgBlurs[0].radius || 0) + 'px' } }); }
      var layerBlurs = s.effects.filter(e => e.type === 'LAYER_BLUR' && e.visible);
      if (layerBlurs.length) { setNested(t.effect, s.name + (sh.length ? '/layer-blur' : ''), { $type: 'blur', $value: { type: 'layer', radius: (layerBlurs[0].radius || 0) + 'px' } }); }
    }
  }
  return JSON.stringify(t, null, 2);
}

function setNested(obj, path, value) {
  const parts = path.split('/');
  let target = obj;
  for (let i = 0; i < parts.length - 1; i++) { const k = parts[i].trim(); if (!target[k]) target[k] = {}; target = target[k]; }
  target[parts[parts.length - 1].trim()] = value;
}

// ═══════════════════════════════════════
// VARIABLES FORMAT CONVERTERS
// ═══════════════════════════════════════

function getFilteredVariables() {
  if (!variablesData || !variablesData.collections) return [];
  return variablesData.collections.filter(c => selectedCollections.has(c.id));
}

function resolveValueStr(val) {
  if (!val) return 'null';
  if (val.type === 'alias') return '{' + val.aliasName + '}';
  if (val.type === 'color') return val.hex;
  if (val.type === 'number') return String(val.value);
  if (val.type === 'string') return '"' + val.value + '"';
  if (val.type === 'boolean') return String(val.value);
  return String(val.value || 'unknown');
}

function getActiveModes() {
  if (selectedModes.size === 0) return allModes.length ? allModes : [];
  return [...selectedModes];
}

function formatVariablesFigma() {
  const cols = getFilteredVariables();
  const result = { _meta: variablesData._meta, collections: [] };
  const activeModes = getActiveModes();
  for (const c of cols) {
    const col = { name: c.name, modes: c.modes, variables: c.variables };
    if (activeModes.length < allModes.length) {
      col.variables = c.variables.map(v => {
        const filtered = {};
        for (const m of activeModes) { filtered[m] = v.valuesByMode[m]; }
        return { ...v, valuesByMode: filtered };
      });
    }
    result.collections.push(col);
  }
  return JSON.stringify(result, null, 2);
}

function formatVariablesCSS() {
  const cols = getFilteredVariables();
  let o = '/* Variables \u2014 CSS Custom Properties */\n\n';
  const modes = getActiveModes();

  for (const modeName of modes) {
    const selector = modes.length === 1 ? ':root' : (modeName === allModes[0] ? ':root' : '[data-mode="' + toSlug(modeName) + '"]');
    o += selector + ' {\n';
    for (const c of cols) {
      o += '  /* ' + c.name + ' */\n';
      for (const v of c.variables) {
        const val = v.valuesByMode[modeName];
        if (!val) continue;
        const slug = toSlug(c.name + '/' + v.name);
        if (val.type === 'color') {
          const a = val.a !== undefined ? val.a : 1;
          o += '  --' + slug + ': ' + (a < 1 ? 'rgba(' + val.r + ',' + val.g + ',' + val.b + ',' + a.toFixed(2) + ')' : val.hex) + ';\n';
        } else if (val.type === 'number') {
          o += '  --' + slug + ': ' + val.value + ';\n';
        } else if (val.type === 'string') {
          o += '  --' + slug + ': ' + val.value + ';\n';
        } else if (val.type === 'boolean') {
          o += '  --' + slug + ': ' + (val.value ? '1' : '0') + ';\n';
        } else if (val.type === 'alias') {
          o += '  --' + slug + ': var(--' + toSlug(val.aliasName) + ');\n';
        }
      }
      o += '\n';
    }
    o += '}\n\n';
  }
  return o;
}

function resolveAliasValue(val, modeName, visited) {
  if (!val || val.type !== 'alias') return val;
  if (!variablesData || !variablesData.collections) return null;
  if (!visited) visited = {};
  if (visited[val.aliasId]) return null;
  visited[val.aliasId] = true;
  for (var ci = 0; ci < variablesData.collections.length; ci++) {
    var vars = variablesData.collections[ci].variables;
    for (var vi = 0; vi < vars.length; vi++) {
      if (vars[vi].id === val.aliasId) {
        var target = vars[vi].valuesByMode[modeName];
        if (!target) {
          var mk = Object.keys(vars[vi].valuesByMode);
          if (mk.length > 0) target = vars[vi].valuesByMode[mk[0]];
        }
        if (!target) return null;
        if (target.type === 'alias') return resolveAliasValue(target, modeName, visited);
        return target;
      }
    }
  }
  return null;
}

function _flutterVarLine(name, val) {
  if (val.type === 'color') return '  static const ' + name + ' = ' + hexToFlutterColor(val.hex, val.a) + ';\n';
  if (val.type === 'number') return '  static const ' + name + ' = ' + val.value + ';\n';
  if (val.type === 'string') return "  static const " + name + " = '" + val.value + "';\n";
  if (val.type === 'boolean') return '  static const ' + name + ' = ' + val.value + ';\n';
  return '';
}

function formatVariablesFlutter() {
  const cols = getFilteredVariables();
  const activeModes = getActiveModes();
  let o = "import 'package:flutter/material.dart';\n\n";

  var baseCls = getFlutterClassName();
  for (const c of cols) {
    var colSuffix = cols.length > 1 ? c.name.replace(/[^a-zA-Z0-9]/g, '') : '';

    if (activeModes.length > 1) {
      // ── Multi-mode: one class per mode ──
      for (const mode of activeModes) {
        var className = baseCls + colSuffix + toPascalCase(mode);
        o += 'abstract class ' + className + ' {\n  ' + className + '._();\n\n';
        for (const v of c.variables) {
          let val = v.valuesByMode[mode];
          if (!val) continue;
          if (val.type === 'alias') { val = val.resolvedValue || resolveAliasValue(val, mode); if (!val) continue; }
          o += _flutterVarLine(toCamel(v.name), val);
        }
        o += '}\n\n';
      }
    } else {
      // ── Single-mode ──
      var className = baseCls + colSuffix;
      o += 'abstract class ' + className + ' {\n  ' + className + '._();\n\n';
      const modeName = activeModes[0] || allModes[0];
      for (const v of c.variables) {
        let val = v.valuesByMode[modeName];
        if (!val) continue;
        if (val.type === 'alias') { val = val.resolvedValue || resolveAliasValue(val, modeName); if (!val) continue; }
        o += _flutterVarLine(toCamel(v.name), val);
      }
      o += '}\n\n';
    }
  }
  return o;
}

function formatVariablesDTCG() {
  const cols = getFilteredVariables();
  const activeModes = getActiveModes();
  const t = {};

  for (const c of cols) {
    t[c.name] = {};
    if (activeModes.length > 1) {
      // Multi-mode: nest by mode
      for (const mode of activeModes) {
        t[c.name][mode] = {};
        for (const v of c.variables) {
          const val = v.valuesByMode[mode];
          if (!val) continue;
          const token = {};
          if (val.type === 'color') { token.$type = 'color'; token.$value = val.hex + alphaToHex(val.a); }
          else if (val.type === 'number') { token.$type = 'number'; token.$value = val.value; }
          else if (val.type === 'string') { token.$type = 'string'; token.$value = val.value; }
          else if (val.type === 'boolean') { token.$type = 'boolean'; token.$value = val.value; }
          else if (val.type === 'alias') { token.$type = 'alias'; token.$value = '{' + val.aliasName + '}'; }
          setNested(t[c.name][mode], v.name, token);
        }
      }
    } else {
      const modeName = activeModes[0] || allModes[0];
      for (const v of c.variables) {
        const val = v.valuesByMode[modeName];
        if (!val) continue;
        const token = {};
        if (val.type === 'color') { token.$type = 'color'; token.$value = val.hex + alphaToHex(val.a); }
        else if (val.type === 'number') { token.$type = 'number'; token.$value = val.value; }
        else if (val.type === 'string') { token.$type = 'string'; token.$value = val.value; }
        else if (val.type === 'boolean') { token.$type = 'boolean'; token.$value = val.value; }
        else if (val.type === 'alias') { token.$type = 'alias'; token.$value = '{' + val.aliasName + '}'; }
        setNested(t[c.name], v.name, token);
      }
    }
  }
  return JSON.stringify(t, null, 2);
}

// ═══════════════════════════════════════
// OUTPUT LOGIC
// ═══════════════════════════════════════

function getFormattedOutput() {
  if (currentSection === 'styles') {
    if (!stylesData) return '';
    const filtered = getFilteredStyles();
    if (currentFormat === 'css') return formatStylesCSS(filtered);
    if (currentFormat === 'flutter') return formatStylesFlutter(filtered);
    if (currentFormat === 'dtcg') return formatStylesDTCG(filtered);
    return JSON.stringify(filtered, null, 2);
  } else {
    if (!variablesData) return '';
    if (currentFormat === 'css') return formatVariablesCSS();
    if (currentFormat === 'flutter') return formatVariablesFlutter();
    if (currentFormat === 'dtcg') return formatVariablesDTCG();
    return formatVariablesFigma();
  }
}

function getFileInfo() {
  const prefix = currentSection === 'styles' ? 'ds-styles' : 'ds-variables';
  if (currentFormat === 'css') return { ext: '.css', mime: 'text/css', label: 'CSS Custom Properties', prefix };
  if (currentFormat === 'flutter') return { ext: '.dart', mime: 'text/plain', label: 'Flutter/Dart', prefix };
  if (currentFormat === 'dtcg') return { ext: '.tokens.json', mime: 'application/json', label: 'W3C DTCG Tokens', prefix };
  return { ext: '.json', mime: 'application/json', label: 'Figma JSON', prefix };
}

function updateOutput() {
  var raw = getFormattedOutput();
  var highlighted = highlightCode(raw, currentFormat);
  document.getElementById('output-code').innerHTML = highlighted;
  var info = getFileInfo();
  document.getElementById('file-hint').textContent = info.label + '  \u2022  ' + info.prefix + info.ext;
}

// ── Syntax highlighting ──
function esc(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function highlightJSON(code) {
  return code.split('\n').map(function(line) {
    var tokens = [];
    var i = 0;
    while (i < line.length) {
      // String
      if (line[i] === '"') {
        var j = i + 1;
        while (j < line.length && line[j] !== '"') { if (line[j] === '\\') j++; j++; }
        var str = line.substring(i, j + 1);
        // Check if it's a key (followed by colon)
        var rest = line.substring(j + 1);
        var colonMatch = rest.match(/^(\s*:)/);
        if (colonMatch) {
          tokens.push({ t: 'key', v: str });
          tokens.push({ t: 'colon', v: colonMatch[1] });
          i = j + 1 + colonMatch[1].length;
        } else {
          tokens.push({ t: 'str', v: str });
          i = j + 1;
        }
        continue;
      }
      // Number
      var nm = line.substring(i).match(/^-?\d+\.?\d*(?:[eE][+-]?\d+)?/);
      if (nm && (i === 0 || ' ,:[\n'.indexOf(line[i - 1]) !== -1)) {
        tokens.push({ t: 'num', v: nm[0] }); i += nm[0].length; continue;
      }
      // Keywords
      var kw = line.substring(i).match(/^(true|false|null)\b/);
      if (kw) {
        tokens.push({ t: kw[1] === 'null' ? 'null' : 'bool', v: kw[1] }); i += kw[1].length; continue;
      }
      // Braces
      if ('{}[]'.indexOf(line[i]) !== -1) { tokens.push({ t: 'brace', v: line[i] }); i++; continue; }
      // Comma
      if (line[i] === ',') { tokens.push({ t: 'comma', v: ',' }); i++; continue; }
      // Whitespace and other
      tokens.push({ t: '', v: line[i] }); i++;
    }
    var cls = { key: 'hl-key', str: 'hl-str', num: 'hl-num', bool: 'hl-bool', 'null': 'hl-null', brace: 'hl-brace', colon: 'hl-colon', comma: 'hl-comma' };
    var html = '';
    for (var tk of tokens) {
      var e = esc(tk.v);
      html += cls[tk.t] ? '<span class="' + cls[tk.t] + '">' + e + '</span>' : e;
    }
    return '<span class="code-line">' + html + '</span>';
  }).join('\n');
}

function highlightCSS(code) {
  return code.split('\n').map(function(line) {
    // Full-line comment
    if (/^\s*\/[/*]/.test(line)) {
      return '<span class="code-line"><span class="hl-comment">' + esc(line) + '</span></span>';
    }
    // Property: value line
    var propMatch = line.match(/^(\s*)(--[\w-]+|[\w-]+)(\s*:\s*)(.+?)(;?\s*)$/);
    if (propMatch) {
      var indent = propMatch[1], prop = propMatch[2], colon = propMatch[3], val = propMatch[4], end = propMatch[5];
      // Tokenize the value part
      var valHtml = esc(val)
        .replace(/(#[0-9a-fA-F]{3,8})/g, '<span class="hl-num">$1</span>')
        .replace(/(\d+\.?\d*)(px|rem|em|%|deg|s|ms|vw|vh)/g, '<span class="hl-num">$1</span><span class="hl-unit">$2</span>');
      var html = esc(indent) + '<span class="hl-prop">' + esc(prop) + '</span>' +
        '<span class="hl-colon">' + esc(colon) + '</span>' +
        '<span class="hl-val">' + valHtml + '</span>' + esc(end);
      return '<span class="code-line">' + html + '</span>';
    }
    // Selector (line ending with {)
    var selMatch = line.match(/^(\s*)([\w.:*\-\[\]>#~,\s]+)(\s*\{)\s*$/);
    if (selMatch) {
      return '<span class="code-line">' + esc(selMatch[1]) +
        '<span class="hl-selector">' + esc(selMatch[2]) + '</span>' +
        '<span class="hl-brace">' + esc(selMatch[3]) + '</span></span>';
    }
    // Closing brace
    var braceMatch = line.match(/^(\s*)(})\s*$/);
    if (braceMatch) {
      return '<span class="code-line">' + esc(braceMatch[1]) + '<span class="hl-brace">' + esc(braceMatch[2]) + '</span></span>';
    }
    return '<span class="code-line">' + esc(line) + '</span>';
  }).join('\n');
}

function highlightDart(code) {
  var keywords = ['import','abstract','class','static','const','final','var','void','int','double','String','bool','return','if','else','new','this','super','extends','implements','with','get','set','factory'];
  var types = ['Color','FontWeight','TextStyle','BoxShadow','Offset'];

  return code.split('\n').map(function(line) {
    // Split comment from code (on raw text, not escaped)
    var commentIdx = line.indexOf('//');
    var codePart = commentIdx !== -1 ? line.substring(0, commentIdx) : line;
    var commentPart = commentIdx !== -1 ? line.substring(commentIdx) : '';

    // Tokenize the code part on raw text
    var tokens = [];
    var i = 0;
    while (i < codePart.length) {
      // String literal
      if (codePart[i] === "'" || codePart[i] === '"') {
        var q = codePart[i], j = i + 1;
        while (j < codePart.length && codePart[j] !== q) { if (codePart[j] === '\\') j++; j++; }
        tokens.push({ t: 'str', v: codePart.substring(i, j + 1) }); i = j + 1; continue;
      }
      // Annotation
      if (codePart[i] === '@') {
        var am = codePart.substring(i).match(/^@\w+/);
        if (am) { tokens.push({ t: 'annotation', v: am[0] }); i += am[0].length; continue; }
      }
      // Word
      var wm = codePart.substring(i).match(/^[a-zA-Z_]\w*/);
      if (wm) {
        var w = wm[0];
        tokens.push({ t: keywords.indexOf(w) !== -1 ? 'keyword' : types.indexOf(w) !== -1 ? 'type' : 'var', v: w });
        i += w.length; continue;
      }
      // Number (hex or decimal) — only if not preceded by a letter
      var nm = codePart.substring(i).match(/^(0x[0-9a-fA-F]+|\d+\.?\d*)/);
      if (nm) { tokens.push({ t: 'num', v: nm[1] }); i += nm[1].length; continue; }
      // Operators
      if ('=><+-*/%&|^!'.indexOf(codePart[i]) !== -1) {
        var om = codePart.substring(i).match(/^(=>|[=+\-*\/%&|^!<>]+)/);
        if (om) { tokens.push({ t: 'op', v: om[0] }); i += om[0].length; continue; }
      }
      // Braces / parens
      if ('{}[]()'.indexOf(codePart[i]) !== -1) { tokens.push({ t: 'brace', v: codePart[i] }); i++; continue; }
      // Punctuation
      if (codePart[i] === ';' || codePart[i] === ',') { tokens.push({ t: 'punct', v: codePart[i] }); i++; continue; }
      // Anything else (whitespace, colons, dots)
      tokens.push({ t: '', v: codePart[i] }); i++;
    }

    // Build HTML — escape THEN wrap in spans
    var html = '';
    var cls = { keyword: 'hl-keyword', type: 'hl-type', str: 'hl-str', num: 'hl-num', annotation: 'hl-annotation', op: 'hl-operator', brace: 'hl-brace', punct: 'hl-comma' };
    for (var tk of tokens) {
      var e = esc(tk.v);
      html += cls[tk.t] ? '<span class="' + cls[tk.t] + '">' + e + '</span>' : e;
    }
    if (commentPart) html += '<span class="hl-comment">' + esc(commentPart) + '</span>';

    return '<span class="code-line">' + html + '</span>';
  }).join('\n');
}

function highlightCode(code, format) {
  if (!code) return '';
  if (format === 'css') return highlightCSS(code);
  if (format === 'flutter') return highlightDart(code);
  // JSON and DTCG are both JSON
  return highlightJSON(code);
}

// ═══════════════════════════════════════
// UI UPDATERS
// ═══════════════════════════════════════

function updateStyleStats() {
  if (!stylesData) return;
  const filtered = getFilteredStyles();
  const b = {
    paint: filtered.paintStyles.length,
    text: filtered.textStyles.length,
    effect: filtered.effectStyles.length,
    grid: filtered.gridStyles.length,
  };
  updateStatEl('paint', b.paint);
  updateStatEl('text', b.text);
  updateStatEl('effect', b.effect);
  updateStatEl('grid', b.grid);
  prevStylesBreakdown = { ...b };
}

function updateStatEl(type, newVal) {
  const el = document.getElementById('count-' + type);
  const statEl = document.getElementById('stat-' + type);
  const diffEl = document.getElementById('diff-' + type);
  if (!el) return;
  const oldVal = prevStylesBreakdown ? prevStylesBreakdown[type] : null;
  el.textContent = newVal;
  if (oldVal !== null && oldVal !== newVal) {
    const diff = newVal - oldVal;
    diffEl.textContent = (diff > 0 ? '+' : '') + diff;
    diffEl.className = 'stat-diff visible' + (diff < 0 ? ' negative' : '');
    statEl.classList.add('changed');
    setTimeout(() => { diffEl.classList.remove('visible'); statEl.classList.remove('changed'); }, 3000);
  }
}

function buildCollectionsList() {
  const list = document.getElementById('collections-list');
  if (!variablesData || !variablesData._meta.available || !variablesData.collections.length) {
    list.innerHTML = '<div class="empty-state"><div class="empty-icon">&#x1f4e6;</div><p>No variable collections found in this file.</p></div>';
    return;
  }

  // Collect all unique modes
  const modeSet = new Map();
  for (const c of variablesData.collections) {
    for (const m of c.modes) { modeSet.set(m.name, m.id); }
  }
  allModes = [...modeSet.keys()];

  // Build collection checkboxes
  list.innerHTML = '';
  for (const c of variablesData.collections) {
    selectedCollections.add(c.id);
    const div = document.createElement('div');
    div.className = 'collection-item';
    const modeNames = c.modes.map(m => m.name).join(', ');
    const typeCount = {};
    for (const v of c.variables) { typeCount[v.resolvedType] = (typeCount[v.resolvedType] || 0) + 1; }
    const typeStr = Object.entries(typeCount).map(([k, v]) => v + ' ' + k.toLowerCase()).join(' \u2022 ');

    div.innerHTML = '<input type="checkbox" checked data-col-id="' + c.id + '">' +
      '<div class="collection-info">' +
      '<div class="collection-name">' + c.name + '</div>' +
      '<div class="collection-meta"><span>' + c.variableCount + ' vars</span><span>' + c.modes.length + ' mode' + (c.modes.length > 1 ? 's' : '') + ': ' + modeNames + '</span></div>' +
      '</div>';
    list.appendChild(div);
  }

  // Build mode chips
  buildModeChips();
  updateVariableStats();
}

function buildModeChips() {
  const container = document.getElementById('mode-selector');
  container.innerHTML = '';
  if (allModes.length <= 1) { selectedModes = new Set(allModes); return; }

  // "All" toggle chip
  const allChip = document.createElement('button');
  allChip.type = 'button';
  allChip.className = 'mode-chip active';
  allChip.dataset.mode = '__all__';
  allChip.textContent = 'All modes';
  container.appendChild(allChip);

  for (const mode of allModes) {
    const chip = document.createElement('button');
    chip.type = 'button';
    chip.className = 'mode-chip active';
    chip.dataset.mode = mode;
    chip.textContent = mode;
    container.appendChild(chip);
  }
  selectedModes = new Set(allModes);
}

function updateVariableStats() {
  const container = document.getElementById('stats-variables');
  const cols = getFilteredVariables();
  let total = 0; let colors = 0; let numbers = 0; let strings = 0; let booleans = 0;
  for (const c of cols) {
    for (const v of c.variables) {
      total++;
      if (v.resolvedType === 'COLOR') colors++;
      else if (v.resolvedType === 'FLOAT') numbers++;
      else if (v.resolvedType === 'STRING') strings++;
      else if (v.resolvedType === 'BOOLEAN') booleans++;
    }
  }
  container.innerHTML = '';
  const items = [['Color', colors], ['Number', numbers], ['String', strings], ['Boolean', booleans]];
  for (const [label, count] of items) {
    if (count > 0) {
      container.innerHTML += '<div class="stat"><div class="stat-number">' + count + '</div><div class="stat-label">' + label + '</div></div>';
    }
  }
}

function setSyncState(state) {
  const badge = document.getElementById('sync-badge');
  const label = document.getElementById('sync-label');
  const btn = document.getElementById('btn-sync');
  const btnText = document.getElementById('sync-text');
  badge.className = 'sync-badge ' + state;
  btn.className = 'btn btn-sync' + (state === 'syncing' ? ' syncing' : '');
  label.textContent = state === 'syncing' ? 'Syncing...' : 'Synced';
  btnText.textContent = state === 'syncing' ? 'Syncing...' : 'Sync';
}

function updateTimestamp() {
  if (!lastSyncTime) return;
  const el = document.getElementById('last-updated');
  const d = Math.floor((new Date() - lastSyncTime) / 1000);
  if (d < 5) el.textContent = 'Just now';
  else if (d < 60) el.textContent = d + 's ago';
  else if (d < 3600) el.textContent = Math.floor(d / 60) + 'm ago';
  else el.textContent = lastSyncTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

function startTimer() { if (timerInterval) clearInterval(timerInterval); timerInterval = setInterval(updateTimestamp, 5000); }

// ═══════════════════════════════════════
// RECEIVE DATA FROM PLUGIN
// ═══════════════════════════════════════

window.onmessage = (event) => {
  const msg = event.data.pluginMessage;
  if (msg.type === 'all-data') {
    stylesData = msg.payload.styles;
    variablesData = msg.payload.variables;
    syncCount++;
    lastSyncTime = new Date();

    const fileName = stylesData._meta.fileName;
    document.getElementById('subtitle').textContent = fileName;
    document.getElementById('badge-styles').textContent = stylesData._meta.totalStyles;
    document.getElementById('badge-variables').textContent = variablesData._meta.totalVariables || 0;

    buildStyleGroupsList();
    updateStyleStats();
    buildCollectionsList();
    updateOutput();

    document.getElementById('btn-copy').disabled = false;
    document.getElementById('btn-download').disabled = false;
    document.getElementById('btn-publish').disabled = false;
    document.getElementById('btn-docs').disabled = false;
    document.getElementById('btn-var-docs').disabled = false;

    setSyncState('synced');
    updateTimestamp();
    startTimer();

    if (syncCount > 1) showToast('Synced \u2014 ' + stylesData._meta.totalStyles + ' styles, ' + (variablesData._meta.totalVariables || 0) + ' variables');
  }

  if (msg.type === 'doc-progress') {
    if (msg.isVariable) {
      // Variable documentation progress
      const vBtn = document.getElementById('btn-var-docs');
      if (msg.status === 'starting') {
        vBtn.className = 'btn-docs generating';
        vBtn.textContent = 'Generating variables...';
        showToast('Generating variable documentation...');
      } else if (msg.status === 'generating') {
        vBtn.textContent = 'Group ' + msg.current + '/' + msg.total + ': ' + msg.name + '...';
      } else if (msg.status === 'done') {
        vBtn.className = 'btn-docs';
        vBtn.disabled = false;
        vBtn.textContent = '\u25B8 Generate Variables Documentation';
        showToast('Done \u2014 ' + (msg.varCount || 0) + ' variables in ' + msg.pageCount + ' group' + (msg.pageCount > 1 ? 's' : ''));
      }
    } else {
      // Style documentation progress
      const btn = document.getElementById('btn-docs');
      if (msg.status === 'starting') {
        btn.className = 'btn-docs generating';
        btn.textContent = 'Generating...';
        showToast('Generating documentation...');
      } else if (msg.status === 'generating') {
        btn.textContent = 'Page ' + msg.current + '/' + msg.total + ': ' + msg.name + '...';
      } else if (msg.status === 'done') {
        btn.className = 'btn-docs';
        btn.disabled = false;
        btn.textContent = '\u25B8 Generate Documentation';
        showToast('Done \u2014 ' + msg.pageCount + ' page' + (msg.pageCount > 1 ? 's' : '') + ' created');
      }
    }
  }

  if (msg.type === 'live-sync-status') {
    isDocLive = msg.active;
    document.getElementById('live-badge').classList.toggle('active', msg.active);
    updateMiniBar();
  }

  // ── Bitbucket credential responses ──
  if (msg.type === 'bb-creds-data') {
    _pubCredsLoaded = true;
    if (msg.payload) {
      document.getElementById('pub-workspace').value = msg.payload.workspace || '';
      document.getElementById('pub-repo').value = msg.payload.repo || '';
      document.getElementById('pub-username').value = msg.payload.username || '';
      document.getElementById('pub-password').value = msg.payload.password || '';

      // Auto-check connection if all fields are filled
      var _ws = msg.payload.workspace || '';
      var _repo = msg.payload.repo || '';
      var _user = msg.payload.username || '';
      var _pw = msg.payload.password || '';
      if (_ws && _repo && _user && _pw) {
        // Silent auto-connect
        (async () => {
          try {
            var bd;
            try { bd = await bbGetBranch('main'); } catch(e) { bd = await bbGetBranch('master'); }
            _pubConnected = true;
            pubUpdateCredsSummary(true, _ws, _repo);
            pubSetCredsCollapsed(true);
            _pubBranchesLoaded = false;
            loadBranches();
            _pubMembersLoaded = false;
            loadMembers();
          } catch(e) {
            _pubConnected = false;
            pubUpdateCredsSummary(false);
            pubSetCredsCollapsed(false);
          }
        })();
      }
    }
  }
  if (msg.type === 'bb-creds-saved') {
    showToast('Credentials saved');
  }
  if (msg.type === 'bb-creds-deleted') {
    _pubCredsLoaded = false;
    _pubConnected = false;
    _pubBranchesLoaded = false;
    _pubBranches = [];
    _pubMembersLoaded = false;
    _pubMembers = [];
    _pubSelectedReviewers = [];
    pubUpdateCredsSummary(false);
    pubSetCredsCollapsed(false);
    document.getElementById('pub-mention-row').innerHTML = '';
  }
  if (msg.type === 'bb-reviewers-data') {
    // Filter out any saved reviewers with corrupt UUIDs from previous sessions
    var uuidRe = /^\{[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\}$/i;
    var raw = msg.payload || [];
    _pubSavedReviewers = raw.filter(function(r) { return r.uuid && uuidRe.test(r.uuid); });
    if (_pubSavedReviewers.length < raw.length) {
      console.warn('Cleaned ' + (raw.length - _pubSavedReviewers.length) + ' saved reviewer(s) with invalid UUID');
      parent.postMessage({ pluginMessage: { type: 'bb-save-reviewers', payload: _pubSavedReviewers } }, '*');
    }
  }
  if (msg.type === 'bb-config-data') {
    // Only store — never apply mid-session (avoids overwriting user's current selection)
    if (msg.payload) _pubLastConfig = msg.payload;
  }

  if (msg.type === 'live-sync-update') {
    if (isMinimized) {
      var el = document.getElementById('mini-updated');
      el.textContent = msg.count + ' updated';
      setTimeout(function() { el.textContent = ''; }, 3000);
    }
    showToast(msg.count + ' style' + (msg.count > 1 ? 's' : '') + ' updated');
  }
};

// ═══════════════════════════════════════
// EVENT HANDLERS
// ═══════════════════════════════════════

// Main section toggle
document.getElementById('main-tabs').onclick = (e) => {
  const tab = e.target.closest('.main-tab');
  if (!tab) return;
  document.querySelectorAll('.main-tab').forEach(t => t.classList.remove('active'));
  tab.classList.add('active');
  currentSection = tab.dataset.section;
  document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
  document.getElementById('section-' + currentSection).classList.add('active');
  updateOutput();
};

// Format tabs
document.getElementById('format-tabs').onclick = (e) => {
  const tab = e.target.closest('.format-tab');
  if (!tab) return;
  document.querySelectorAll('.format-tab').forEach(t => t.classList.remove('active'));
  tab.classList.add('active');
  currentFormat = tab.dataset.format;
  updateOutput();
};

// Collection checkboxes
document.getElementById('collections-list').onchange = (e) => {
  if (e.target.type === 'checkbox') {
    const id = e.target.dataset.colId;
    if (e.target.checked) selectedCollections.add(id);
    else selectedCollections.delete(id);
    updateVariableStats();
    updateOutput();
  }
};

// Select all / none
document.getElementById('btn-select-all').onclick = () => {
  document.querySelectorAll('#collections-list input[type="checkbox"]').forEach(cb => { cb.checked = true; selectedCollections.add(cb.dataset.colId); });
  updateVariableStats();
  updateOutput();
};
document.getElementById('btn-select-none').onclick = () => {
  document.querySelectorAll('#collections-list input[type="checkbox"]').forEach(cb => { cb.checked = false; });
  selectedCollections.clear();
  updateVariableStats();
  updateOutput();
};

// Style groups: accordion toggle
document.getElementById('sg-toggle').onclick = (e) => {
  if (e.target.closest('button')) return;
  sgOpen = !sgOpen;
  document.getElementById('sg-arrow').classList.toggle('open', sgOpen);
  document.getElementById('sg-body').classList.toggle('open', sgOpen);
};

// Style groups: chip removal (× button)
document.getElementById('sg-chips').onclick = (e) => {
  const x = e.target.closest('.sg-chip-x');
  if (!x) return;
  const group = x.dataset.group;
  selectedStyleGroups.delete(group);
  const cb = document.querySelector('#style-groups-list input[data-style-group="' + CSS.escape(group) + '"]');
  if (cb) cb.checked = false;
  updateStyleGroupChips();
  updateStyleStats();
  updateOutput();
};

// Style groups: checkbox changes
document.getElementById('style-groups-list').onchange = (e) => {
  if (e.target.type === 'checkbox') {
    const group = e.target.dataset.styleGroup;
    if (e.target.checked) selectedStyleGroups.add(group);
    else selectedStyleGroups.delete(group);
    updateStyleGroupChips();
    updateStyleStats();
    updateOutput();
  }
};

// Style groups: All / None
document.getElementById('btn-sg-all').onclick = (e) => {
  e.stopPropagation();
  document.querySelectorAll('#style-groups-list input[type="checkbox"]').forEach(cb => { cb.checked = true; selectedStyleGroups.add(cb.dataset.styleGroup); });
  updateStyleGroupChips();
  updateStyleStats();
  updateOutput();
};
document.getElementById('btn-sg-none').onclick = (e) => {
  e.stopPropagation();
  document.querySelectorAll('#style-groups-list input[type="checkbox"]').forEach(cb => { cb.checked = false; });
  selectedStyleGroups.clear();
  updateStyleGroupChips();
  updateStyleStats();
  updateOutput();
};

// Mode chips (multi-select)
document.getElementById('mode-selector').onclick = (e) => {
  const chip = e.target.closest('.mode-chip');
  if (!chip) return;
  const mode = chip.dataset.mode;

  if (mode === '__all__') {
    // "All" chip: select all modes
    selectedModes = new Set(allModes);
  } else {
    // Toggle individual mode
    if (selectedModes.has(mode)) {
      if (selectedModes.size > 1) selectedModes.delete(mode);
    } else {
      selectedModes.add(mode);
    }
  }

  // Update chip visuals
  document.querySelectorAll('.mode-chip').forEach(c => {
    if (c.dataset.mode === '__all__') {
      c.classList.toggle('active', selectedModes.size === allModes.length);
    } else {
      c.classList.toggle('active', selectedModes.has(c.dataset.mode));
    }
  });

  updateOutput();
};

// Generate Documentation
document.getElementById('btn-docs').onclick = () => {
  if (!stylesData || selectedStyleGroups.size === 0) return;

  const groups = [];
  for (const groupName of selectedStyleGroups) {
    groups.push({
      groupName: groupName,
      styles: {
        paintStyles: stylesData.paintStyles.filter(s => getStyleGroup(s.name) === groupName),
        textStyles: stylesData.textStyles.filter(s => getStyleGroup(s.name) === groupName),
        effectStyles: stylesData.effectStyles.filter(s => getStyleGroup(s.name) === groupName),
        gridStyles: stylesData.gridStyles.filter(s => getStyleGroup(s.name) === groupName),
      }
    });
  }

  document.getElementById('btn-docs').disabled = true;
  parent.postMessage({ pluginMessage: { type: 'generate-docs', payload: { groups: groups } } }, '*');
};

// ═══════════════════════════════════════
// VARIABLE GROUPS MODAL (tree with nested sub-groups)
// ═══════════════════════════════════════

let _varModalTree = [];
let _varModalCollection = null;

function openVarModal(collection) {
  _varModalCollection = collection;
  _varModalTree = [];

  // Build tree: top group → sub-groups
  const topMap = {};
  const topOrder = [];

  for (const v of collection.variables) {
    const parts = v.name.split('/');
    const topName = parts.length > 1 ? parts[0] : 'General';

    if (!topMap[topName]) {
      topMap[topName] = { variables: [], subMap: {}, subOrder: [] };
      topOrder.push(topName);
    }
    topMap[topName].variables.push(v);

    // Sub-group by second path segment (only if 3+ segments)
    if (parts.length > 2) {
      const subName = parts[1];
      if (!topMap[topName].subMap[subName]) {
        topMap[topName].subMap[subName] = [];
        topMap[topName].subOrder.push(subName);
      }
      topMap[topName].subMap[subName].push(v);
    }
  }

  topOrder.sort();

  for (const name of topOrder) {
    const data = topMap[name];
    data.subOrder.sort();

    const subGroups = data.subOrder.map(sn => ({
      name: sn,
      count: data.subMap[sn].length,
      checked: true,
      variables: data.subMap[sn]
    }));

    _varModalTree.push({
      name: name,
      count: data.variables.length,
      hasSubGroups: subGroups.length > 1,
      expanded: false,
      checked: true,
      subGroups: subGroups,
      variables: data.variables
    });
  }

  renderVarModal();
  document.getElementById('var-modal-sub').textContent =
    collection.name + ' collection \u00B7 ' + collection.variables.length + ' variables';
  updateVarModalCount();
  document.getElementById('var-modal-overlay').classList.add('open');
}

function closeVarModal() {
  document.getElementById('var-modal-overlay').classList.remove('open');
}

function renderVarModal() {
  const body = document.getElementById('var-modal-body');
  body.innerHTML = '';

  for (let i = 0; i < _varModalTree.length; i++) {
    const group = _varModalTree[i];

    const wrapper = document.createElement('div');
    wrapper.className = 'var-modal-group';

    // ── Parent row ──
    const parentRow = document.createElement('div');
    parentRow.className = 'var-modal-item parent';

    // Expand arrow
    const expandEl = document.createElement('span');
    expandEl.className = 'var-expand' + (group.hasSubGroups ? '' : ' hidden');
    expandEl.innerHTML = '&#x25B8;';
    expandEl.dataset.idx = i;
    parentRow.appendChild(expandEl);

    // Checkbox
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = group.checked;
    cb.dataset.parentIdx = i;
    parentRow.appendChild(cb);

    // Name
    const nameEl = document.createElement('span');
    nameEl.className = 'var-modal-item-name';
    nameEl.textContent = group.name;
    parentRow.appendChild(nameEl);

    // Sub-groups badge
    if (group.hasSubGroups) {
      const subBadge = document.createElement('span');
      subBadge.className = 'var-modal-item-sub';
      subBadge.textContent = group.subGroups.length + ' sub-groups';
      parentRow.appendChild(subBadge);
    }

    // Count
    const countEl = document.createElement('span');
    countEl.className = 'var-modal-item-count';
    countEl.textContent = group.count;
    parentRow.appendChild(countEl);

    wrapper.appendChild(parentRow);

    // ── Children (sub-groups) ──
    if (group.hasSubGroups) {
      const childrenEl = document.createElement('div');
      childrenEl.className = 'var-modal-children';
      childrenEl.dataset.parentIdx = i;

      for (let j = 0; j < group.subGroups.length; j++) {
        const sub = group.subGroups[j];

        const childRow = document.createElement('div');
        childRow.className = 'var-modal-item child';

        const childCb = document.createElement('input');
        childCb.type = 'checkbox';
        childCb.checked = sub.checked;
        childCb.dataset.parentIdx = i;
        childCb.dataset.subIdx = j;

        const childName = document.createElement('span');
        childName.className = 'var-modal-item-name';
        childName.textContent = sub.name;

        const childCount = document.createElement('span');
        childCount.className = 'var-modal-item-count';
        childCount.textContent = sub.count;

        childRow.appendChild(childCb);
        childRow.appendChild(childName);
        childRow.appendChild(childCount);
        childrenEl.appendChild(childRow);
      }

      wrapper.appendChild(childrenEl);
    }

    body.appendChild(wrapper);
  }
}

function updateVarModalCount() {
  let checkedCount = 0;
  let selVars = 0;
  let totalItems = 0;

  for (const group of _varModalTree) {
    if (group.hasSubGroups) {
      for (const sub of group.subGroups) {
        totalItems++;
        if (sub.checked) { checkedCount++; selVars += sub.count; }
      }
    } else {
      totalItems++;
      if (group.checked) { checkedCount++; selVars += group.count; }
    }
  }

  document.getElementById('var-modal-count').textContent =
    checkedCount + ' / ' + totalItems + ' \u00B7 ' + selVars + ' vars';
}

function syncParentCheckbox(parentIdx) {
  const group = _varModalTree[parentIdx];
  if (!group.hasSubGroups) return;

  const allChecked = group.subGroups.every(s => s.checked);
  const someChecked = group.subGroups.some(s => s.checked);

  group.checked = allChecked;

  const parentCb = document.querySelector(
    'input[data-parent-idx="' + parentIdx + '"]:not([data-sub-idx])'
  );
  if (parentCb) {
    parentCb.checked = allChecked;
    parentCb.indeterminate = !allChecked && someChecked;
  }
}

// ── Event delegation: expand arrows ──
document.getElementById('var-modal-body').onclick = (e) => {
  const expandEl = e.target.closest('.var-expand:not(.hidden)');
  if (!expandEl) return;

  e.preventDefault();
  const idx = parseInt(expandEl.dataset.idx);
  const group = _varModalTree[idx];
  group.expanded = !group.expanded;
  expandEl.classList.toggle('open', group.expanded);

  const childrenEl = document.querySelector(
    '.var-modal-children[data-parent-idx="' + idx + '"]'
  );
  if (childrenEl) childrenEl.classList.toggle('open', group.expanded);
};

// ── Event delegation: checkboxes ──
document.getElementById('var-modal-body').onchange = (e) => {
  if (e.target.type !== 'checkbox') return;

  const parentIdx = parseInt(e.target.dataset.parentIdx);
  const subIdx = e.target.dataset.subIdx;

  if (subIdx !== undefined) {
    // Child checkbox
    _varModalTree[parentIdx].subGroups[parseInt(subIdx)].checked = e.target.checked;
    syncParentCheckbox(parentIdx);
  } else {
    // Parent checkbox
    const group = _varModalTree[parentIdx];
    group.checked = e.target.checked;
    e.target.indeterminate = false;

    if (group.hasSubGroups) {
      for (const sub of group.subGroups) sub.checked = e.target.checked;
      // Sync children DOM
      document.querySelectorAll(
        'input[data-parent-idx="' + parentIdx + '"][data-sub-idx]'
      ).forEach(cb => { cb.checked = e.target.checked; });
    }
  }

  updateVarModalCount();
};

// ── All / None ──
document.getElementById('var-modal-all').onclick = () => {
  for (const group of _varModalTree) {
    group.checked = true;
    for (const sub of group.subGroups) sub.checked = true;
  }
  document.querySelectorAll('#var-modal-body input[type="checkbox"]').forEach(cb => {
    cb.checked = true; cb.indeterminate = false;
  });
  updateVarModalCount();
};
document.getElementById('var-modal-none').onclick = () => {
  for (const group of _varModalTree) {
    group.checked = false;
    for (const sub of group.subGroups) sub.checked = false;
  }
  document.querySelectorAll('#var-modal-body input[type="checkbox"]').forEach(cb => {
    cb.checked = false; cb.indeterminate = false;
  });
  updateVarModalCount();
};

// ── Close / Cancel ──
document.getElementById('var-modal-close').onclick = closeVarModal;
document.getElementById('var-modal-cancel').onclick = closeVarModal;

// ── Generate ──
document.getElementById('var-modal-generate').onclick = () => {
  const selectedGroups = [];

  for (const group of _varModalTree) {
    if (group.hasSubGroups) {
      // Each checked sub-group → separate frame
      for (const sub of group.subGroups) {
        if (sub.checked) {
          selectedGroups.push({
            groupName: group.name + ' / ' + sub.name,
            depth: 2,
            variables: sub.variables
          });
        }
      }
    } else {
      // Flat group → one frame
      if (group.checked) {
        selectedGroups.push({
          groupName: group.name,
          depth: 1,
          variables: group.variables
        });
      }
    }
  }

  if (selectedGroups.length === 0) {
    showToast('Select at least one group.');
    return;
  }

  closeVarModal();
  document.getElementById('btn-var-docs').disabled = true;

  parent.postMessage({
    pluginMessage: {
      type: 'generate-var-docs',
      payload: {
        collectionName: _varModalCollection.name,
        modes: _varModalCollection.modes,
        groups: selectedGroups
      }
    }
  }, '*');
};

// ── Button: opens modal (Components only) ──
document.getElementById('btn-var-docs').onclick = () => {
  if (!variablesData || !variablesData.collections || !variablesData.collections.length) return;

  // Find components collection
  var compCol = null;
  for (var i = 0; i < variablesData.collections.length; i++) {
    if (variablesData.collections[i].name.toLowerCase() === 'components') {
      compCol = variablesData.collections[i];
      break;
    }
  }

  if (!compCol) {
    showToast('No "Components" collection found in this file.');
    return;
  }

  if (!selectedCollections.has(compCol.id)) {
    showToast('Select the Components collection to generate documentation.');
    return;
  }

  var otherSelected = false;
  for (var c of variablesData.collections) {
    if (c.id !== compCol.id && selectedCollections.has(c.id)) {
      otherSelected = true;
      break;
    }
  }
  if (otherSelected) {
    showToast('Only Components collection is supported for now. Deselect other collections.');
    return;
  }

  openVarModal(compCol);
};

// Sync
document.getElementById('btn-sync').onclick = () => {
  setSyncState('syncing');
  parent.postMessage({ pluginMessage: { type: 'sync' } }, '*');
};

// Copy
document.getElementById('btn-copy').onclick = () => {
  const text = getFormattedOutput();
  function fallbackCopy() {
    var ta = document.createElement('textarea');
    ta.value = text;
    ta.style.position = 'fixed';
    ta.style.opacity = '0';
    document.body.appendChild(ta);
    ta.focus();
    ta.select();
    try { document.execCommand('copy'); } catch(e) {}
    document.body.removeChild(ta);
    showToast('Copied ' + getFileInfo().label);
  }
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(text).then(() => {
      showToast('Copied ' + getFileInfo().label);
    }).catch(fallbackCopy);
  } else {
    fallbackCopy();
  }
};

// Download
document.getElementById('btn-download').onclick = () => {
  const text = getFormattedOutput();
  const info = getFileInfo();
  const blob = new Blob([text], { type: info.mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const ts = new Date().toISOString().slice(0, 10);
  a.download = info.prefix + '-' + ts + info.ext;
  a.click();
  URL.revokeObjectURL(url);
  showToast('Downloaded ' + info.prefix + '-' + ts + info.ext);
};

// Close
document.getElementById('btn-close').onclick = () => {
  parent.postMessage({ pluginMessage: { type: 'close' } }, '*');
};

// ═══════════════════════════════════════
// PUBLISH TO BITBUCKET
// ═══════════════════════════════════════

let _pubStep = 1;
let _pubScope = 'styles';
let _pubFormat = 'figma';
let _pubContent = '';
let _pubBranchName = '';
let _pubPrUrl = '';
let _pubCredsLoaded = false;
let _pubBranchMode = 'new';       // 'new' or 'existing'
let _pubSelectedBranch = '';       // selected existing branch name
let _pubBranches = [];             // fetched branches list
let _pubBranchesLoaded = false;
let _pubConnected = false;         // true after successful check connection
let _pubCredsCollapsed = false;
let _pubMembers = [];           // workspace members list
let _pubMembersLoaded = false;  // whether members have been fetched
let _pubSelectedReviewers = []; // array of { displayName, uuid, nickname }
let _pubSavedReviewers = [];    // manually saved reviewers (persisted across sessions)

// ── Selection summary in publish modal ──
function pubUpdateSelectionSummary() {
  var container = document.getElementById('pub-selection-content');
  var scopeLabels = { styles: 'Styles', variables: 'Variables' };
  var html = '';

  // Styles summary
  if (_pubScope === 'styles') {
    if (selectedStyleGroups.size === 0) {
      var totalGroups = document.querySelectorAll('#style-groups-list input[type="checkbox"]').length;
      html += '<div class="pub-sel-group">';
      html += '<div class="pub-sel-label">Styles — All groups (' + totalGroups + ')</div>';
      html += '</div>';
    } else {
      html += '<div class="pub-sel-group">';
      html += '<div class="pub-sel-label">Styles — ' + selectedStyleGroups.size + ' group' + (selectedStyleGroups.size > 1 ? 's' : '') + '</div>';
      html += '<div class="pub-sel-chips">';
      var filtered = getFilteredStyles();
      for (var name of [...selectedStyleGroups].sort()) {
        var count = 0;
        if (filtered) {
          count += filtered.paintStyles.filter(function(s) { return getStyleGroup(s.name) === name; }).length;
          count += filtered.textStyles.filter(function(s) { return getStyleGroup(s.name) === name; }).length;
          count += filtered.effectStyles.filter(function(s) { return getStyleGroup(s.name) === name; }).length;
          count += filtered.gridStyles.filter(function(s) { return getStyleGroup(s.name) === name; }).length;
        }
        html += '<span class="pub-sel-chip">' + name + (count ? ' <span class="pub-sel-count">' + count + '</span>' : '') + '</span>';
      }
      html += '</div>';
      html += '</div>';
    }
  }

  // Variables summary
  if (_pubScope === 'variables') {
    if (!variablesData || !variablesData.collections || selectedCollections.size === 0) {
      html += '<div class="pub-sel-group">';
      html += '<span class="pub-sel-none">No collections selected — go back and select collections first</span>';
      html += '</div>';
    } else {
      html += '<div class="pub-sel-group">';
      html += '<div class="pub-sel-label">Collections</div>';
      html += '<div class="pub-sel-chips">';
      for (var col of variablesData.collections) {
        if (!selectedCollections.has(col.id)) continue;
        html += '<span class="pub-sel-chip">' + col.name + ' <span class="pub-sel-count">' + col.variables.length + ' vars</span></span>';
      }
      html += '</div>';
      // Modes (only show if not all selected)
      if (selectedModes.size > 0 && selectedModes.size < allModes.length) {
        html += '<div class="pub-sel-label" style="margin-top:6px">Modes</div>';
        html += '<div class="pub-sel-chips">';
        for (var mode of selectedModes) {
          html += '<span class="pub-sel-chip">' + mode + '</span>';
        }
        html += '</div>';
      }
      html += '</div>';
    }
  }

  container.innerHTML = html;
}

// ── File extensions map ──
function pubFileExt(fmt) {
  if (fmt === 'css') return '.css';
  if (fmt === 'flutter') return '.dart';
  if (fmt === 'dtcg') return '.tokens.json';
  return '.json';
}

// ── Build export content ──
function buildExportContent(scope, format) {
  if (scope === 'styles') {
    const data = getFilteredStyles();
    if (!data) return '';
    if (format === 'css') return formatStylesCSS(data);
    if (format === 'flutter') return formatStylesFlutter(data);
    if (format === 'dtcg') return formatStylesDTCG(data);
    return JSON.stringify(data, null, 2);
  }
  if (scope === 'variables') {
    if (!variablesData) return '';
    if (format === 'css') return formatVariablesCSS();
    if (format === 'flutter') return formatVariablesFlutter();
    if (format === 'dtcg') return formatVariablesDTCG();
    return formatVariablesFigma();
  }
  // Both: combine styles + variables
  if (format === 'css') {
    let o = '';
    const sData = getFilteredStyles();
    if (sData) o += formatStylesCSS(sData) + '\n';
    if (variablesData) o += formatVariablesCSS();
    return o;
  }
  if (format === 'flutter') {
    let o = '';
    const sData = getFilteredStyles();
    if (sData) o += formatStylesFlutter(sData) + '\n';
    if (variablesData) o += formatVariablesFlutter();
    return o;
  }
  if (format === 'figma' || format === 'dtcg') {
    const combined = {};
    const sData = getFilteredStyles();
    if (sData) {
      if (format === 'dtcg') {
        try { Object.assign(combined, JSON.parse(formatStylesDTCG(sData))); } catch(e) {}
      } else {
        combined.styles = sData;
      }
    }
    if (variablesData) {
      if (format === 'dtcg') {
        try { Object.assign(combined, JSON.parse(formatVariablesDTCG())); } catch(e) {}
      } else {
        combined.variables = JSON.parse(formatVariablesFigma());
      }
    }
    return JSON.stringify(combined, null, 2);
  }
  return '';
}

// ── Default file path ──
function pubDefaultFilePath(scope, format) {
  const ext = pubFileExt(format);
  if (scope === 'both') return 'ds/tokens/ds-tokens' + ext;
  return 'ds/tokens/ds-' + scope + ext;
}

// ── Smart path update: keep user's directory, rebuild filename from scope + format ──
function pubUpdateFilePath(newFormat) {
  var current = document.getElementById('pub-filepath').value.trim();
  if (!current) { document.getElementById('pub-filepath').value = pubDefaultFilePath(_pubScope, newFormat); return; }
  // Extract the directory portion (everything up to and including the last /)
  var lastSlash = current.lastIndexOf('/');
  var dir = lastSlash >= 0 ? current.substring(0, lastSlash + 1) : '';
  // Build new filename from current scope + format extension
  var ext = pubFileExt(newFormat);
  var base = 'ds-' + (_pubScope === 'both' ? 'tokens' : _pubScope);
  document.getElementById('pub-filepath').value = dir + base + ext;
}

// ── Default branch name ──
function pubDefaultBranch(scope) {
  const d = new Date();
  const ds = d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
  return 'design-tokens/' + ds + '-' + scope;
}

// ── Last PR config persistence ──
// Stores non-volatile preferences (format, file path directory, PR title pattern,
// description, reviewers). Scope is ALWAYS derived from the current tab — never saved.
let _pubLastConfig = null;

function pubSaveConfig() {
  // Extract the directory from the file path (everything before the last /)
  var fp = document.getElementById('pub-filepath').value.trim();
  var dir = fp.lastIndexOf('/') >= 0 ? fp.substring(0, fp.lastIndexOf('/') + 1) : '';
  var config = {
    format: _pubFormat,
    fileDir: dir,
    prTitle: document.getElementById('pub-pr-title').value.trim(),
    prDesc: document.getElementById('pub-pr-desc').value.trim(),
    reviewers: _pubSelectedReviewers
  };
  parent.postMessage({ pluginMessage: { type: 'bb-save-config', payload: config } }, '*');
}

function pubApplyConfig(config) {
  if (!config) return;
  _pubLastConfig = config;
  // NOTE: scope is NOT restored — it always comes from the active tab (currentSection)
  // Only format, directory, PR template, and reviewers are restored
}

// ── Bitbucket API helpers ──
function bbAuth() {
  const u = document.getElementById('pub-username').value.trim();
  const p = document.getElementById('pub-password').value.trim();
  return 'Basic ' + btoa(u + ':' + p);
}

function bbBaseUrl() {
  const ws = document.getElementById('pub-workspace').value.trim();
  const repo = document.getElementById('pub-repo').value.trim();
  return 'https://api.bitbucket.org/2.0/repositories/' + encodeURIComponent(ws) + '/' + encodeURIComponent(repo);
}

async function bbGetBranch(branch) {
  const res = await fetch(bbBaseUrl() + '/refs/branches/' + encodeURIComponent(branch), {
    headers: { 'Authorization': bbAuth() }
  });
  if (!res.ok) {
    const err = await res.text();
    throw new Error('Branch check failed (' + res.status + '): ' + err);
  }
  return await res.json();
}

async function bbCreateBranch(name, fromHash) {
  const res = await fetch(bbBaseUrl() + '/refs/branches', {
    method: 'POST',
    headers: { 'Authorization': bbAuth(), 'Content-Type': 'application/json' },
    body: JSON.stringify({ name: name, target: { hash: fromHash } })
  });
  if (!res.ok) {
    const err = await res.text();
    throw new Error('Branch creation failed (' + res.status + '): ' + err);
  }
  return await res.json();
}

async function bbCommitFile(branch, filePath, content, message) {
  if (!content || !content.trim()) {
    throw new Error('Nothing to commit — exported content is empty. Check that you have styles or variables synced.');
  }
  const form = new FormData();
  form.append('branch', branch);
  form.append('message', message);
  // Bitbucket /src endpoint expects file content as a plain string value,
  // with the form field name being the file path
  form.append(filePath, content);

  const res = await fetch(bbBaseUrl() + '/src', {
    method: 'POST',
    headers: { 'Authorization': bbAuth() },
    body: form
  });
  if (!res.ok) {
    const err = await res.text();
    throw new Error('Commit failed (' + res.status + '): ' + err);
  }
  return res;
}

async function bbCreatePR(sourceBranch, title, description, reviewers) {
  var body = {
    title: title,
    description: description,
    source: { branch: { name: sourceBranch } },
    close_source_branch: true
  };
  if (reviewers && reviewers.length > 0) {
    var uuidRe = /^\{[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\}$/i;
    var mapped = [];
    for (var i = 0; i < reviewers.length; i++) {
      var r = reviewers[i];
      if (r.uuid && uuidRe.test(r.uuid)) {
        mapped.push({ uuid: r.uuid });
      } else if (r.accountId) {
        mapped.push({ account_id: r.accountId });
      } else if (r.uuid) {
        // Try to fix UUID format — add braces if missing
        var fixed = r.uuid.startsWith('{') ? r.uuid : '{' + r.uuid + '}';
        if (uuidRe.test(fixed)) {
          mapped.push({ uuid: fixed });
        } else {
          console.warn('Skipped reviewer with invalid UUID:', r.uuid);
        }
      }
    }
    if (mapped.length > 0) {
      body.reviewers = mapped;
    }
  }
  console.log('[bbCreatePR] Request body:', JSON.stringify(body, null, 2));
  console.log('[bbCreatePR] Raw reviewers input:', JSON.stringify(reviewers, null, 2));
  const res = await fetch(bbBaseUrl() + '/pullrequests', {
    method: 'POST',
    headers: { 'Authorization': bbAuth(), 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });
  if (!res.ok) {
    const err = await res.text();
    throw new Error('PR creation failed (' + res.status + '): ' + err);
  }
  return await res.json();
}

// ── List all branches ──
async function bbListBranches() {
  let branches = [];
  let url = bbBaseUrl() + '/refs/branches?pagelen=100&sort=-target.date';
  while (url) {
    const res = await fetch(url, { headers: { 'Authorization': bbAuth() } });
    if (!res.ok) throw new Error('Failed to load branches (' + res.status + ')');
    const data = await res.json();
    for (const b of data.values) {
      var dateStr = '';
      if (b.target && b.target.date) {
        var d = new Date(b.target.date);
        dateStr = d.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
      }
      branches.push({
        name: b.name,
        hash: b.target ? b.target.hash : '',
        date: dateStr,
        isDefault: b.name === 'main' || b.name === 'master'
      });
    }
    url = data.next || null;
    if (branches.length >= 200) break; // safety cap
  }
  return branches;
}

// ── List workspace members + repo permissions (merged, deduplicated) ──
async function bbListMembers() {
  var seen = {};
  var members = [];

  function addMember(u) {
    var uuid = u.uuid || '';
    if (!uuid || seen[uuid]) return;
    seen[uuid] = true;
    members.push({
      displayName: u.display_name || u.nickname || '',
      uuid: uuid,
      nickname: u.nickname || '',
      accountId: u.account_id || '',
      avatarUrl: (u.links && u.links.avatar && u.links.avatar.href) || ''
    });
  }

  // Source 1: workspace members
  try {
    var ws = document.getElementById('pub-workspace').value.trim();
    var url = 'https://api.bitbucket.org/2.0/workspaces/' + encodeURIComponent(ws) + '/members?pagelen=100';
    while (url) {
      var res = await fetch(url, { headers: { 'Authorization': bbAuth() } });
      if (!res.ok) break;
      var data = await res.json();
      for (var m of data.values) { addMember(m.user || m); }
      url = data.next || null;
      if (members.length >= 200) break;
    }
  } catch (e) { /* continue to next source */ }

  // Source 2: repo-level user permissions (catches users added directly to the repo)
  try {
    var url2 = bbBaseUrl() + '/permissions-config/users?pagelen=100';
    while (url2) {
      var res2 = await fetch(url2, { headers: { 'Authorization': bbAuth() } });
      if (!res2.ok) break;
      var data2 = await res2.json();
      for (var p of data2.values) { addMember(p.user || p); }
      url2 = data2.next || null;
      if (members.length >= 300) break;
    }
  } catch (e) { /* optional — some plans may not support this endpoint */ }

  // Sort alphabetically by display name
  members.sort(function(a, b) { return a.displayName.localeCompare(b.displayName); });
  return members;
}

// ── Fetch existing file content from a branch ──
async function bbGetFileContent(branch, filePath) {
  var url = bbBaseUrl() + '/src/' + encodeURIComponent(branch) + '/' + filePath.split('/').map(encodeURIComponent).join('/');
  var res = await fetch(url, { headers: { 'Authorization': bbAuth() } });
  if (res.status === 404) return null; // file doesn't exist yet
  if (!res.ok) throw new Error('Failed to fetch file (' + res.status + ')');
  return await res.text();
}

// ── Simple line-based diff (LCS) ──
function computeLineDiff(oldLines, newLines) {
  var m = oldLines.length;
  var n = newLines.length;
  // Build LCS table
  var dp = [];
  for (var i = 0; i <= m; i++) {
    dp[i] = [];
    for (var j = 0; j <= n; j++) {
      if (i === 0 || j === 0) dp[i][j] = 0;
      else if (oldLines[i - 1] === newLines[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
      else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
    }
  }
  // Backtrack to produce diff
  var result = [];
  var i = m, j = n;
  while (i > 0 || j > 0) {
    if (i > 0 && j > 0 && oldLines[i - 1] === newLines[j - 1]) {
      result.unshift({ type: 'context', oldLn: i, newLn: j, text: oldLines[i - 1] });
      i--; j--;
    } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
      result.unshift({ type: 'added', newLn: j, text: newLines[j - 1] });
      j--;
    } else {
      result.unshift({ type: 'removed', oldLn: i, text: oldLines[i - 1] });
      i--;
    }
  }
  return result;
}

async function loadMembers() {
  if (_pubMembersLoaded) return;
  try {
    _pubMembers = await bbListMembers();
    _pubMembersLoaded = true;
    renderMentionRow();
  } catch (err) {
    // Silently fail — members are optional
  }
}

function renderMentionRow() {
  var row = document.getElementById('pub-mention-row');
  if (!_pubMembersLoaded || _pubMembers.length === 0) { row.innerHTML = ''; return; }
  var html = '<span class="pub-mention-label">Mention:</span>';
  var shown = _pubMembers.slice(0, 5);
  for (var m of shown) {
    html += '<span class="pub-mention-chip" data-nick="' + m.nickname.replace(/"/g, '&quot;') + '">@' + m.nickname + '</span>';
  }
  if (_pubMembers.length > 5) {
    html += '<span class="pub-mention-more" id="pub-mention-more">+' + (_pubMembers.length - 5) + ' more</span>';
  }
  row.innerHTML = html;
}

function getAllKnownMembers() {
  // Merge API members + saved reviewers, deduplicated by UUID
  var seen = {};
  var all = [];
  for (var m of _pubMembers) {
    if (!seen[m.uuid]) { seen[m.uuid] = true; all.push(m); }
  }
  for (var s of _pubSavedReviewers) {
    if (!seen[s.uuid]) { seen[s.uuid] = true; all.push(s); }
  }
  return all;
}

function renderMemberDropdown(filter) {
  var list = document.getElementById('pub-member-list');
  var allMembers = getAllKnownMembers();
  var filtered = allMembers;
  if (filter) {
    var f = filter.toLowerCase();
    filtered = allMembers.filter(function(m) {
      return m.displayName.toLowerCase().includes(f) || m.nickname.toLowerCase().includes(f);
    });
  }
  if (filtered.length === 0) {
    list.innerHTML = '<div class="pub-member-empty">' +
      (filter ? 'No members match &ldquo;' + filter.replace(/</g,'&lt;') + '&rdquo;<br><span style="font-size:10px;margin-top:4px;display:inline-block">Press <strong>Enter</strong> or <strong>+</strong> to add manually</span>' : 'No members loaded') +
      '</div>';
    return;
  }

  // Separate saved (manual) from API members for clear grouping
  var savedUuids = {};
  for (var s of _pubSavedReviewers) savedUuids[s.uuid] = true;

  var apiMembers = filtered.filter(function(m) { return !savedUuids[m.uuid]; });
  var savedMembers = filtered.filter(function(m) { return savedUuids[m.uuid]; });

  var html = '';

  // Saved reviewers section
  if (savedMembers.length > 0) {
    html += '<div class="pub-member-group-label">Saved reviewers</div>';
    for (var m of savedMembers) {
      var isSelected = _pubSelectedReviewers.some(function(r) { return r.uuid === m.uuid; });
      html += '<div class="pub-member-item' + (isSelected ? ' selected' : '') + '" data-uuid="' + m.uuid.replace(/"/g, '&quot;') + '">';
      html += '<span class="pub-member-avatar pub-member-avatar-saved">&#x2606;</span>';
      html += '<span class="pub-member-name">' + m.displayName + '</span>';
      html += '<span class="pub-member-nick">@' + m.nickname + '</span>';
      if (isSelected) html += '<span class="pub-member-tick">&#x2713;</span>';
      html += '<span class="pub-member-remove" data-remove-uuid="' + m.uuid.replace(/"/g, '&quot;') + '" title="Remove saved reviewer">&#x2715;</span>';
      html += '</div>';
    }
  }

  // API workspace/repo members
  if (apiMembers.length > 0) {
    if (savedMembers.length > 0) html += '<div class="pub-member-group-label">Workspace members</div>';
    for (var m of apiMembers) {
      var isSelected = _pubSelectedReviewers.some(function(r) { return r.uuid === m.uuid; });
      html += '<div class="pub-member-item' + (isSelected ? ' selected' : '') + '" data-uuid="' + m.uuid.replace(/"/g, '&quot;') + '">';
      if (m.avatarUrl) {
        html += '<img class="pub-member-avatar" src="' + m.avatarUrl + '" alt="">';
      } else {
        html += '<span class="pub-member-avatar"></span>';
      }
      html += '<span class="pub-member-name">' + m.displayName + '</span>';
      html += '<span class="pub-member-nick">@' + m.nickname + '</span>';
      if (isSelected) html += '<span class="pub-member-tick">&#x2713;</span>';
      html += '</div>';
    }
  }
  list.innerHTML = html;
}

function renderReviewerChips() {
  var container = document.getElementById('pub-reviewer-chips');
  if (_pubSelectedReviewers.length === 0) { container.innerHTML = ''; return; }
  var html = '';
  for (var r of _pubSelectedReviewers) {
    html += '<span class="pub-reviewer-chip" data-uuid="' + r.uuid.replace(/"/g, '&quot;') + '">' +
      r.displayName + ' <span class="pub-chip-x">&times;</span></span>';
  }
  container.innerHTML = html;
}

function addReviewer(uuid) {
  var m = _pubMembers.find(function(x) { return x.uuid === uuid; });
  if (!m) return;
  if (_pubSelectedReviewers.some(function(r) { return r.uuid === uuid; })) return;
  _pubSelectedReviewers.push({ displayName: m.displayName, uuid: m.uuid, nickname: m.nickname, accountId: m.accountId || '' });
  document.getElementById('pub-reviewer-search').value = '';
  renderReviewerChips();
  renderMemberDropdown('');
}

async function addManualReviewer(input) {
  input = input.trim();
  if (!input) return;
  // Check if it's already added (by UUID or nickname match)
  if (_pubSelectedReviewers.some(function(r) { return r.uuid === input || r.nickname === input; })) {
    showToast('Reviewer already added');
    return;
  }
  // Check if it matches an existing member by nickname, display name, or UUID
  var match = _pubMembers.find(function(m) {
    return m.nickname.toLowerCase() === input.toLowerCase()
      || m.displayName.toLowerCase() === input.toLowerCase()
      || m.uuid === input;
  });
  if (!match) {
    match = _pubSavedReviewers.find(function(m) {
      return m.nickname.toLowerCase() === input.toLowerCase()
        || m.displayName.toLowerCase() === input.toLowerCase()
        || m.uuid === input;
    });
  }
  if (match) {
    if (!_pubSelectedReviewers.some(function(r) { return r.uuid === match.uuid; })) {
      _pubSelectedReviewers.push({ displayName: match.displayName, uuid: match.uuid, nickname: match.nickname });
      document.getElementById('pub-reviewer-search').value = '';
      renderReviewerChips();
      renderMemberDropdown('');
    }
    return;
  }

  // If input looks like a valid UUID (with or without braces), accept it directly
  var uuidPattern = /^\{?[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\}?$/i;
  if (uuidPattern.test(input)) {
    var uuid = input.startsWith('{') ? input : '{' + input + '}';
    var newReviewer = { displayName: input, uuid: uuid, nickname: input };
    _pubSelectedReviewers.push(newReviewer);
    document.getElementById('pub-reviewer-search').value = '';
    renderReviewerChips();
    renderMemberDropdown('');
    saveReviewerToStorage(newReviewer);
    showToast('Reviewer added');
    return;
  }

  // Not a UUID — try to look up by username via Bitbucket API
  var searchInput = document.getElementById('pub-reviewer-search');
  searchInput.disabled = true;
  showToast('Looking up "' + input + '"...');

  try {
    // Try workspace members search first (if not already loaded)
    if (!_pubMembersLoaded) {
      _pubMembers = await bbListMembers();
      _pubMembersLoaded = true;
      renderMentionRow();
    }
    // Re-check loaded members after fresh load
    match = _pubMembers.find(function(m) {
      return m.nickname.toLowerCase() === input.toLowerCase()
        || m.displayName.toLowerCase() === input.toLowerCase();
    });
    if (match) {
      _pubSelectedReviewers.push({ displayName: match.displayName, uuid: match.uuid, nickname: match.nickname });
      document.getElementById('pub-reviewer-search').value = '';
      renderReviewerChips();
      renderMemberDropdown('');
      showToast('Found: ' + match.displayName);
      return;
    }

    // Try Bitbucket user endpoint directly
    var ws = document.getElementById('pub-workspace').value.trim();
    var userRes = await fetch(
      'https://api.bitbucket.org/2.0/workspaces/' + encodeURIComponent(ws) + '/members?q=user.nickname="' + input.replace(/"/g, '\\"') + '"',
      { headers: { 'Authorization': bbAuth() } }
    );
    if (userRes.ok) {
      var userData = await userRes.json();
      if (userData.values && userData.values.length > 0) {
        var u = userData.values[0].user || userData.values[0];
        var found = {
          displayName: u.display_name || u.nickname || input,
          uuid: u.uuid,
          nickname: u.nickname || input,
          accountId: u.account_id || ''
        };
        _pubSelectedReviewers.push(found);
        document.getElementById('pub-reviewer-search').value = '';
        renderReviewerChips();
        renderMemberDropdown('');
        saveReviewerToStorage(found);
        showToast('Found: ' + found.displayName);
        return;
      }
    }

    // Nothing found — show helpful error
    showToast('User "' + input + '" not found. Use a Bitbucket nickname or UUID.');
  } catch (e) {
    showToast('Lookup failed: ' + (e.message || 'check connection'));
  } finally {
    searchInput.disabled = false;
    searchInput.focus();
  }
}

function saveReviewerToStorage(reviewer) {
  // Only save reviewers with valid UUIDs
  var uuidRe = /^\{[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\}$/i;
  if (!reviewer.uuid || !uuidRe.test(reviewer.uuid)) {
    console.warn('Not saving reviewer with invalid UUID:', reviewer.uuid);
    return;
  }
  if (!_pubSavedReviewers.some(function(r) { return r.uuid === reviewer.uuid; })) {
    _pubSavedReviewers.push(reviewer);
  }
  parent.postMessage({ pluginMessage: { type: 'bb-save-reviewers', payload: _pubSavedReviewers } }, '*');
}

function removeSavedReviewer(uuid) {
  _pubSavedReviewers = _pubSavedReviewers.filter(function(r) { return r.uuid !== uuid; });
  parent.postMessage({ pluginMessage: { type: 'bb-save-reviewers', payload: _pubSavedReviewers } }, '*');
}

function removeReviewer(uuid) {
  _pubSelectedReviewers = _pubSelectedReviewers.filter(function(r) { return r.uuid !== uuid; });
  renderReviewerChips();
  renderMemberDropdown(document.getElementById('pub-reviewer-search').value.trim());
}

function insertMention(nickname) {
  var ta = document.getElementById('pub-pr-desc');
  var start = ta.selectionStart;
  var end = ta.selectionEnd;
  var text = ta.value;
  var mention = '@' + nickname + ' ';
  ta.value = text.substring(0, start) + mention + text.substring(end);
  ta.selectionStart = ta.selectionEnd = start + mention.length;
  ta.focus();
}

// ── Diff rendering ──
function escHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function renderDiffView(oldContent, newContent) {
  var diffWrap = document.getElementById('pub-diff-content');
  var statsEl = document.getElementById('pub-diff-stats');
  diffWrap.innerHTML = '';

  // Show file path in header
  var fp = document.getElementById('pub-filepath').value.trim();
  document.getElementById('pub-diff-filepath').textContent = fp;

  // New file — no old content
  if (oldContent === null) {
    var newLines = newContent.split('\n');
    var addCount = newLines.length;
    statsEl.style.display = '';
    statsEl.innerHTML =
      '<span class="pub-diff-stat-add">+' + addCount + '</span>' +
      '<span class="pub-diff-stat-del">-0</span>' +
      '<span class="pub-diff-stat-label">New file</span>';
    var html = '<div class="pub-diff-hunk">New file &mdash; ' + addCount + ' lines</div>';
    var cap = Math.min(newLines.length, 200);
    for (var i = 0; i < cap; i++) {
      html += '<div class="pub-diff-line added">' +
        '<span class="pub-diff-ln"></span>' +
        '<span class="pub-diff-ln">' + (i + 1) + '</span>' +
        '<span class="pub-diff-code">+ ' + escHtml(newLines[i]) + '</span></div>';
    }
    if (newLines.length > 200) {
      html += '<div class="pub-diff-hunk">... ' + (newLines.length - 200) + ' more lines</div>';
    }
    diffWrap.innerHTML = html;
    return;
  }

  // Existing file — compute diff
  var oldLines = oldContent.split('\n');
  var newLines = newContent.split('\n');

  // Identical check
  if (oldContent === newContent) {
    statsEl.style.display = '';
    statsEl.innerHTML = '<span class="pub-diff-stat-label">No changes &mdash; file content is identical</span>';
    diffWrap.innerHTML = '';
    return;
  }

  var diff = computeLineDiff(oldLines, newLines);

  // Stats
  var added = 0, removed = 0;
  for (var d of diff) {
    if (d.type === 'added') added++;
    if (d.type === 'removed') removed++;
  }

  // Stats bar (max 10 blocks)
  var total = added + removed;
  var barHtml = '<span class="pub-diff-stat-blocks">';
  if (total > 0) {
    var addBlocks = Math.round((added / total) * Math.min(total, 10));
    var delBlocks = Math.min(total, 10) - addBlocks;
    for (var i = 0; i < addBlocks; i++) barHtml += '<span class="add"></span>';
    for (var i = 0; i < delBlocks; i++) barHtml += '<span class="del"></span>';
  }
  barHtml += '</span>';

  statsEl.style.display = '';
  statsEl.innerHTML =
    '<span class="pub-diff-stat-add">+' + added + '</span>' +
    '<span class="pub-diff-stat-del">-' + removed + '</span>' +
    barHtml;

  // Render lines — context-collapsed diff (3 lines context around changes)
  var html = '';
  var contextRadius = 3;
  var show = new Array(diff.length);
  for (var i = 0; i < diff.length; i++) show[i] = false;
  for (var i = 0; i < diff.length; i++) {
    if (diff[i].type !== 'context') {
      for (var j = Math.max(0, i - contextRadius); j <= Math.min(diff.length - 1, i + contextRadius); j++) {
        show[j] = true;
      }
    }
  }

  var prevShown = true;
  var linesCapped = 0;
  for (var i = 0; i < diff.length; i++) {
    if (linesCapped > 500) {
      html += '<div class="pub-diff-hunk">... remainder truncated (' + (diff.length - i) + ' more lines)</div>';
      break;
    }
    if (!show[i]) {
      if (prevShown) {
        html += '<div class="pub-diff-hunk">&hellip;</div>';
      }
      prevShown = false;
      continue;
    }
    prevShown = true;
    linesCapped++;
    var d = diff[i];
    if (d.type === 'context') {
      html += '<div class="pub-diff-line context">' +
        '<span class="pub-diff-ln pub-diff-ln-old">' + d.oldLn + '</span>' +
        '<span class="pub-diff-ln">' + d.newLn + '</span>' +
        '<span class="pub-diff-code">  ' + escHtml(d.text) + '</span></div>';
    } else if (d.type === 'added') {
      html += '<div class="pub-diff-line added">' +
        '<span class="pub-diff-ln pub-diff-ln-old"></span>' +
        '<span class="pub-diff-ln">' + d.newLn + '</span>' +
        '<span class="pub-diff-code">+ ' + escHtml(d.text) + '</span></div>';
    } else {
      html += '<div class="pub-diff-line removed">' +
        '<span class="pub-diff-ln pub-diff-ln-old">' + d.oldLn + '</span>' +
        '<span class="pub-diff-ln"></span>' +
        '<span class="pub-diff-code">- ' + escHtml(d.text) + '</span></div>';
    }
  }
  diffWrap.innerHTML = html;
}

var _pubDiffLoaded = false; // whether diff has already been fetched this review cycle

async function loadDiffView() {
  var diffWrap = document.getElementById('pub-diff-content');
  var statsEl = document.getElementById('pub-diff-stats');
  diffWrap.innerHTML = '<div class="pub-diff-loading">Fetching existing file for comparison...</div>';
  statsEl.style.display = 'none';

  var fp = document.getElementById('pub-filepath').value.trim();
  var fetchBranch = (_pubBranchMode === 'existing') ? _pubSelectedBranch : 'main';

  try {
    var oldContent = await bbGetFileContent(fetchBranch, fp);
    renderDiffView(oldContent, _pubContent);
  } catch (err) {
    try {
      if (fetchBranch === 'main') {
        var oldContent = await bbGetFileContent('master', fp);
        renderDiffView(oldContent, _pubContent);
      } else {
        throw err;
      }
    } catch (e2) {
      renderDiffView(null, _pubContent);
    }
  }
  _pubDiffLoaded = true;
}

function openDiffModal() {
  document.getElementById('pub-diff-overlay').classList.add('open');
  if (!_pubDiffLoaded) loadDiffView();
}

function closeDiffModal() {
  document.getElementById('pub-diff-overlay').classList.remove('open');
}

function renderBranchList(filter) {
  const list = document.getElementById('pub-branch-list');
  const filtered = filter
    ? _pubBranches.filter(b => b.name.toLowerCase().includes(filter.toLowerCase()))
    : _pubBranches;

  if (filtered.length === 0) {
    list.innerHTML = '<div class="pub-branch-empty">No branches found</div>';
    return;
  }

  list.innerHTML = '';
  for (const b of filtered) {
    const item = document.createElement('div');
    item.className = 'pub-branch-item' + (_pubSelectedBranch === b.name ? ' selected' : '');
    item.dataset.branch = b.name;
    item.innerHTML =
      '<span class="pub-branch-item-name">' + b.name + '</span>' +
      (b.isDefault ? '<span class="pub-branch-item-badge">default</span>' : '') +
      (b.date ? '<span class="pub-branch-item-date">' + b.date + '</span>' : '');
    list.appendChild(item);
  }
}

async function loadBranches() {
  if (_pubBranchesLoaded) return;
  const list = document.getElementById('pub-branch-list');
  list.innerHTML = '<div class="pub-branch-loading">Loading branches...</div>';
  try {
    _pubBranches = await bbListBranches();
    _pubBranchesLoaded = true;
    renderBranchList('');
  } catch (err) {
    list.innerHTML = '<div class="pub-branch-empty">Failed to load branches. Check connection first.</div>';
  }
}

function pubSetCredsCollapsed(collapsed) {
  _pubCredsCollapsed = collapsed;
  const body = document.getElementById('pub-creds-body');
  const btn = document.getElementById('pub-creds-expand');
  body.classList.toggle('open', !collapsed);
  btn.textContent = collapsed ? 'Settings' : 'Hide';
}

function pubUpdateCredsSummary(connected, ws, repo) {
  const dot = document.getElementById('pub-creds-dot');
  const summary = document.getElementById('pub-creds-summary');
  if (connected) {
    dot.className = 'pub-creds-dot connected';
    summary.innerHTML = 'Connected to <strong>' + ws + '/' + repo + '</strong>';
  } else {
    dot.className = 'pub-creds-dot disconnected';
    summary.innerHTML = 'Not connected <span>— configure credentials below</span>';
  }
}

// ── Modal open/close ──
function openPublishModal() {
  _pubStep = 1;
  var cfg = _pubLastConfig;

  // ── Scope: ALWAYS from the current tab — no manual override ──
  _pubScope = currentSection;

  // ── Selection summary: show what groups/collections are selected ──
  pubUpdateSelectionSummary();

  // ── Format: restore from saved config, else use current view format ──
  _pubFormat = (cfg && cfg.format) ? cfg.format : currentFormat;
  document.querySelectorAll('input[name="pub-format"]').forEach(r => {
    var label = r.closest('.pub-radio');
    if (r.value === _pubFormat) { r.checked = true; label.classList.add('active'); }
    else { r.checked = false; label.classList.remove('active'); }
  });

  // ── File path: saved directory + scope-based filename + format extension ──
  var ext = pubFileExt(_pubFormat);
  var fileName = 'ds-' + (_pubScope === 'both' ? 'tokens' : _pubScope) + ext;
  var dir = (cfg && cfg.fileDir) ? cfg.fileDir : 'ds/tokens/';
  document.getElementById('pub-filepath').value = dir + fileName;

  // ── Branch name: always fresh (date-based) ──
  document.getElementById('pub-branch-name').value = pubDefaultBranch(_pubScope);

  // ── PR title & description: restore from saved, else defaults ──
  var d = new Date();
  var ds = String(d.getDate()).padStart(2, '0') + '/' + String(d.getMonth() + 1).padStart(2, '0') + '/' + d.getFullYear();
  document.getElementById('pub-pr-title').value = (cfg && cfg.prTitle) ? cfg.prTitle : 'AJBY00: Update ' + _pubScope + ' design tokens';
  document.getElementById('pub-pr-desc').value = (cfg && cfg.prDesc) ? cfg.prDesc : 'Updated ' + _pubScope + ' design tokens exported from Figma on ' + ds + '.\n\nGenerated by DS Styles Extractor plugin.';

  // ── Reviewers: restore from saved ──
  _pubSelectedReviewers = (cfg && cfg.reviewers && cfg.reviewers.length) ? cfg.reviewers : [];
  renderReviewerChips();

  if (_pubMembersLoaded) renderMentionRow();
  document.getElementById('pub-reviewer-search').value = '';
  document.getElementById('pub-member-dropdown').classList.remove('open');

  // Reset branch mode to "new"
  _pubBranchMode = 'new';
  _pubSelectedBranch = '';
  document.querySelectorAll('input[name="pub-branch-mode"]').forEach(r => {
    const label = r.closest('.pub-radio');
    if (r.value === 'new') { r.checked = true; label.classList.add('active'); }
    else { r.checked = false; label.classList.remove('active'); }
  });
  document.getElementById('pub-branch-new').style.display = '';
  document.getElementById('pub-branch-existing').style.display = 'none';
  document.getElementById('pub-branch-display').textContent = 'Select a branch...';
  document.getElementById('pub-branch-dropdown').classList.remove('open');
  document.getElementById('pub-branch-arrow').classList.remove('open');

  // Collapse credentials if connected, else expand
  if (_pubConnected) {
    var ws = document.getElementById('pub-workspace').value.trim();
    var repo = document.getElementById('pub-repo').value.trim();
    pubUpdateCredsSummary(true, ws, repo);
    pubSetCredsCollapsed(true);
  } else {
    pubUpdateCredsSummary(false);
    pubSetCredsCollapsed(false);
  }

  // Load saved credentials and reviewers
  if (!_pubCredsLoaded) {
    parent.postMessage({ pluginMessage: { type: 'bb-get-creds' } }, '*');
  }
  parent.postMessage({ pluginMessage: { type: 'bb-get-reviewers' } }, '*');

  pubShowStep(1);
  document.getElementById('pub-overlay').classList.add('open');
}

function closePublishModal() {
  document.getElementById('pub-overlay').classList.remove('open');
}

function pubShowStep(step) {
  _pubStep = step;

  // Update step indicators
  document.querySelectorAll('.pub-step').forEach(s => {
    const sn = parseInt(s.dataset.pubStep);
    s.classList.remove('active', 'done');
    if (sn === step) s.classList.add('active');
    else if (sn < step) s.classList.add('done');
  });

  // Show/hide step content
  for (let i = 1; i <= 4; i++) {
    document.getElementById('pub-step-' + i).style.display = i === step ? '' : 'none';
  }

  // Update footer buttons
  const backBtn = document.getElementById('pub-back');
  const cancelBtn = document.getElementById('pub-cancel');
  const nextBtn = document.getElementById('pub-next');

  if (step === 1) {
    backBtn.style.display = 'none';
    cancelBtn.style.display = '';
    nextBtn.style.display = '';
    nextBtn.textContent = 'Next: Review';
    nextBtn.disabled = false;
    nextBtn.className = 'btn btn-primary';
  } else if (step === 2) {
    backBtn.style.display = '';
    cancelBtn.style.display = '';
    nextBtn.style.display = '';
    nextBtn.textContent = 'Publish';
    nextBtn.disabled = false;
    nextBtn.className = 'btn btn-primary';
  } else if (step === 3) {
    backBtn.style.display = 'none';
    cancelBtn.style.display = 'none';
    nextBtn.style.display = 'none';
  } else if (step === 4) {
    backBtn.style.display = 'none';
    cancelBtn.style.display = 'none';
    nextBtn.style.display = '';
    nextBtn.textContent = 'Close';
    nextBtn.disabled = false;
    nextBtn.className = 'btn btn-secondary';
  }
}

// ── Validation ──
function pubValidateSettings() {
  const ws = document.getElementById('pub-workspace').value.trim();
  const repo = document.getElementById('pub-repo').value.trim();
  const user = document.getElementById('pub-username').value.trim();
  const pw = document.getElementById('pub-password').value.trim();
  const fp = document.getElementById('pub-filepath').value.trim();
  const title = document.getElementById('pub-pr-title').value.trim();

  if (!ws) { showToast('Workspace is required'); return false; }
  if (!repo) { showToast('Repository is required'); return false; }
  if (!user) { showToast('Email is required'); return false; }
  if (!pw) { showToast('API Token is required'); return false; }
  if (!fp) { showToast('File path is required'); return false; }
  if (!title) { showToast('PR title is required'); return false; }

  // Validate selection
  if (_pubScope === 'styles' && !stylesData) { showToast('No styles data — sync first'); return false; }
  if (_pubScope === 'variables' && (!variablesData || selectedCollections.size === 0)) { showToast('No collections selected — go back and select collections first'); return false; }

  // Validate branch
  if (_pubBranchMode === 'new') {
    const bn = document.getElementById('pub-branch-name').value.trim();
    if (!bn) { showToast('Branch name is required'); return false; }
  } else {
    if (!_pubSelectedBranch) { showToast('Select an existing branch'); return false; }
  }
  return true;
}

// ── Build review ──
function pubBuildReview() {
  _pubContent = buildExportContent(_pubScope, _pubFormat);
  if (!_pubContent || !_pubContent.trim()) {
    showToast('No content to publish — sync your styles or variables first');
    return false;
  }

  // Determine branch name based on mode
  if (_pubBranchMode === 'existing') {
    _pubBranchName = _pubSelectedBranch;
  } else {
    _pubBranchName = document.getElementById('pub-branch-name').value.trim() || pubDefaultBranch(_pubScope);
  }

  const ws = document.getElementById('pub-workspace').value.trim();
  const repo = document.getElementById('pub-repo').value.trim();
  const fp = document.getElementById('pub-filepath').value.trim();
  const title = document.getElementById('pub-pr-title').value.trim();

  const fmtLabels = { figma: 'JSON', css: 'CSS', flutter: 'Flutter', dtcg: 'W3C DTCG' };

  // Build selection summary for review
  var selectionText = '';
  if (_pubScope === 'styles') {
    if (selectedStyleGroups.size === 0) {
      selectionText = 'All style groups';
    } else {
      selectionText = [...selectedStyleGroups].sort().join(', ');
    }
  } else if (_pubScope === 'variables') {
    var colNames = [];
    if (variablesData && variablesData.collections) {
      for (var c of variablesData.collections) {
        if (selectedCollections.has(c.id)) colNames.push(c.name);
      }
    }
    selectionText = colNames.length ? colNames.join(', ') : 'No collections';
  }

  const lines = _pubContent.split('\n').length;

  document.getElementById('pub-review-card').innerHTML =
    '<div class="pub-review-row"><span>Repository</span><span>' + ws + '/' + repo + '</span></div>' +
    '<div class="pub-review-row"><span>Branch</span><span>' + _pubBranchName + '</span></div>' +
    '<div class="pub-review-row"><span>File</span><span>' + fp + '</span></div>' +
    '<div class="pub-review-row"><span>Format</span><span>' + (fmtLabels[_pubFormat] || _pubFormat) + '</span></div>' +
    '<div class="pub-review-row"><span>Selection</span><span>' + selectionText + '</span></div>' +
    '<div class="pub-review-row"><span>Content</span><span>' + lines + ' lines</span></div>' +
    '<div class="pub-review-row"><span>PR title</span><span>' + title + '</span></div>' +
    '<div class="pub-review-row"><span>Reviewers</span><span>' +
      (_pubSelectedReviewers.length ? _pubSelectedReviewers.map(function(r) { return r.displayName; }).join(', ') : 'None') +
    '</span></div>';

  // Truncate preview to first 80 lines for performance
  var previewLines = _pubContent.split('\n');
  var previewText = previewLines.slice(0, 80).join('\n');
  if (previewLines.length > 80) previewText += '\n\n... (' + (previewLines.length - 80) + ' more lines)';
  document.getElementById('pub-preview-content').textContent = previewText;

  // Reset diff state — will load on demand when user clicks "View Code Compare"
  _pubDiffLoaded = false;
}

// ── Progress helpers ──
function pubSetProgress(id, state) {
  const el = document.getElementById(id);
  el.className = state; // '', 'active', 'done', 'error'
  const icon = el.querySelector('.pub-progress-icon');
  if (state === 'done') icon.textContent = '\u2713';
  else if (state === 'error') icon.textContent = '\u2717';
  else if (state === 'active') icon.textContent = '\u25CF';
}

function pubShowError(msg) {
  const el = document.getElementById('pub-error-msg');
  el.textContent = msg;
  el.style.display = '';

  // Show retry button
  const footer = document.getElementById('pub-footer');
  var retryBtn = document.getElementById('pub-retry');
  if (!retryBtn) {
    retryBtn = document.createElement('button');
    retryBtn.id = 'pub-retry';
    retryBtn.className = 'btn btn-primary';
    retryBtn.textContent = 'Retry';
    retryBtn.type = 'button';
    retryBtn.onclick = () => { pubRunPublish(); };
    footer.appendChild(retryBtn);
  }
  retryBtn.style.display = '';
}

// ── Main publish flow ──
async function pubRunPublish() {
  // Reset progress
  document.getElementById('pub-error-msg').style.display = 'none';
  var retryBtn = document.getElementById('pub-retry');
  if (retryBtn) retryBtn.style.display = 'none';

  ['pub-prog-connect', 'pub-prog-check', 'pub-prog-branch', 'pub-prog-commit', 'pub-prog-pr'].forEach(id => {
    pubSetProgress(id, '');
  });
  document.querySelector('#pub-prog-branch .pub-prog-label').textContent = 'Creating branch...';

  const fp = document.getElementById('pub-filepath').value.trim();
  const title = document.getElementById('pub-pr-title').value.trim();
  var desc = document.getElementById('pub-pr-desc').value.trim();
  const commitMsg = title;

  // Append reviewer mentions to description so they get notified
  if (_pubSelectedReviewers.length > 0) {
    var mentions = _pubSelectedReviewers.map(function(r) {
      // Bitbucket mentions use @{accountId} format for notifications
      if (r.accountId) return '@{' + r.accountId + '}';
      return '@' + (r.nickname || r.displayName);
    }).join(' ');
    desc += '\n\nReviewers: ' + mentions;
  }

  try {
    // Step 1: Connect (validate credentials by checking main)
    pubSetProgress('pub-prog-connect', 'active');
    var mainBranch;
    try {
      mainBranch = await bbGetBranch('main');
    } catch (e) {
      // Try 'master' fallback
      try {
        mainBranch = await bbGetBranch('master');
      } catch (e2) {
        throw new Error('Cannot find main/master branch. Check your credentials and repository.');
      }
    }
    pubSetProgress('pub-prog-connect', 'done');

    // Step 2: Check main is up to date (we get the hash)
    pubSetProgress('pub-prog-check', 'active');
    var mainHash = mainBranch.target.hash;
    pubSetProgress('pub-prog-check', 'done');

    // Step 3: Create or use branch
    pubSetProgress('pub-prog-branch', 'active');
    if (_pubBranchMode === 'existing') {
      // Using existing branch — skip creation
      document.querySelector('#pub-prog-branch .pub-prog-label').textContent = 'Using branch ' + _pubBranchName;
    } else {
      document.querySelector('#pub-prog-branch .pub-prog-label').textContent = 'Creating branch ' + _pubBranchName + '...';
      await bbCreateBranch(_pubBranchName, mainHash);
    }
    pubSetProgress('pub-prog-branch', 'done');

    // Step 4: Commit file
    pubSetProgress('pub-prog-commit', 'active');
    await bbCommitFile(_pubBranchName, fp, _pubContent, commitMsg);
    pubSetProgress('pub-prog-commit', 'done');

    // Step 5: Create PR
    pubSetProgress('pub-prog-pr', 'active');
    var pr = await bbCreatePR(_pubBranchName, title, desc, _pubSelectedReviewers);
    pubSetProgress('pub-prog-pr', 'done');

    _pubPrUrl = pr.links.html.href;

    // Move to done step
    document.getElementById('pub-done-summary').textContent = 'Your ' + _pubScope + ' design tokens have been published.';
    document.getElementById('pub-done-link').href = _pubPrUrl;
    document.getElementById('pub-done-link').textContent = 'Open Pull Request';
    document.getElementById('pub-done-branch').textContent = 'Branch: ' + _pubBranchName;

    // Save this config for next time
    pubSaveConfig();

    pubShowStep(4);
    showToast('Pull request created successfully');

  } catch (err) {
    // Find which step was active and mark it as error
    var activeStep = document.querySelector('.pub-progress li.active');
    if (activeStep) activeStep.className = 'error';
    pubShowError(err.message || 'An unexpected error occurred.');
  }
}

// ── Event handlers ──

// Open modal
document.getElementById('btn-publish').onclick = () => {
  if (!stylesData && !variablesData) return;
  openPublishModal();
};

// Close
document.getElementById('pub-close').onclick = closePublishModal;
document.getElementById('pub-cancel').onclick = closePublishModal;

// Password toggle
document.getElementById('pub-pw-toggle').onclick = () => {
  const pw = document.getElementById('pub-password');
  pw.type = pw.type === 'password' ? 'text' : 'password';
};

// Scope radios removed — scope is now set automatically from the current tab

// Format radios
document.getElementById('pub-format-radios').onclick = (e) => {
  const label = e.target.closest('.pub-radio');
  if (!label) return;
  const radio = label.querySelector('input');
  if (!radio) return;
  document.querySelectorAll('#pub-format-radios .pub-radio').forEach(r => r.classList.remove('active'));
  label.classList.add('active');
  radio.checked = true;
  _pubFormat = radio.value;
  pubUpdateFilePath(_pubFormat);
};

// Save credentials
document.getElementById('pub-save-creds').onclick = () => {
  const creds = {
    workspace: document.getElementById('pub-workspace').value.trim(),
    repo: document.getElementById('pub-repo').value.trim(),
    username: document.getElementById('pub-username').value.trim(),
    password: document.getElementById('pub-password').value.trim()
  };
  if (!creds.workspace || !creds.repo || !creds.username || !creds.password) {
    showToast('Fill in all credential fields first');
    return;
  }
  parent.postMessage({ pluginMessage: { type: 'bb-save-creds', payload: creds } }, '*');
};

// Clear credentials
document.getElementById('pub-clear-creds').onclick = () => {
  document.getElementById('pub-workspace').value = '';
  document.getElementById('pub-repo').value = '';
  document.getElementById('pub-username').value = '';
  document.getElementById('pub-password').value = '';
  parent.postMessage({ pluginMessage: { type: 'bb-delete-creds' } }, '*');
  showToast('Credentials cleared');
};

// Check connection
document.getElementById('pub-check-conn').onclick = async () => {
  const ws = document.getElementById('pub-workspace').value.trim();
  const repo = document.getElementById('pub-repo').value.trim();
  const user = document.getElementById('pub-username').value.trim();
  const pw = document.getElementById('pub-password').value.trim();

  if (!ws || !repo || !user || !pw) {
    showToast('Fill in all credential fields first');
    return;
  }

  const btn = document.getElementById('pub-check-conn');
  const status = document.getElementById('pub-conn-status');

  btn.disabled = true;
  btn.classList.add('checking');
  btn.textContent = 'Checking...';
  status.className = 'pub-conn-status visible checking';
  status.textContent = 'Connecting to ' + ws + '/' + repo + '...';

  try {
    var branchData;
    try {
      branchData = await bbGetBranch('main');
    } catch (e) {
      branchData = await bbGetBranch('master');
    }

    var branchName = branchData.name || 'main';
    var lastCommit = branchData.target.message || '';
    if (lastCommit.length > 60) lastCommit = lastCommit.substring(0, 60) + '...';

    status.className = 'pub-conn-status visible success';
    status.innerHTML = 'Connected to <strong>' + ws + '/' + repo + '</strong>' +
      '<br>Branch: ' + branchName +
      (lastCommit ? '<br>Last commit: ' + lastCommit : '');

    _pubConnected = true;
    pubUpdateCredsSummary(true, ws, repo);

    // Auto-load branches and members in background
    _pubBranchesLoaded = false;
    loadBranches();
    _pubMembersLoaded = false;
    loadMembers();
  } catch (err) {
    _pubConnected = false;
    pubUpdateCredsSummary(false);
    status.className = 'pub-conn-status visible error';
    status.textContent = 'Connection failed: ' + (err.message || 'Check your credentials and repository name.');
  } finally {
    btn.disabled = false;
    btn.classList.remove('checking');
    btn.textContent = 'Check connection';
  }
};

// Credentials collapse toggle
document.getElementById('pub-creds-header').onclick = (e) => {
  if (e.target.closest('.pub-creds-toggle') || e.target.classList.contains('pub-creds-toggle')) {
    pubSetCredsCollapsed(!_pubCredsCollapsed);
  } else {
    pubSetCredsCollapsed(!_pubCredsCollapsed);
  }
};

// Branch mode toggle
document.querySelector('.pub-branch-toggle').onclick = (e) => {
  const label = e.target.closest('.pub-radio');
  if (!label) return;
  const radio = label.querySelector('input');
  if (!radio) return;

  document.querySelectorAll('.pub-branch-toggle .pub-radio').forEach(r => r.classList.remove('active'));
  label.classList.add('active');
  radio.checked = true;
  _pubBranchMode = radio.value;

  document.getElementById('pub-branch-new').style.display = _pubBranchMode === 'new' ? '' : 'none';
  document.getElementById('pub-branch-existing').style.display = _pubBranchMode === 'existing' ? '' : 'none';

  if (_pubBranchMode === 'existing' && !_pubBranchesLoaded) {
    loadBranches();
  }
};

// Branch dropdown trigger
document.getElementById('pub-branch-trigger').onclick = () => {
  const dd = document.getElementById('pub-branch-dropdown');
  const arrow = document.getElementById('pub-branch-arrow');
  const isOpen = dd.classList.contains('open');
  dd.classList.toggle('open', !isOpen);
  arrow.classList.toggle('open', !isOpen);
  if (!isOpen) {
    document.getElementById('pub-branch-search').value = '';
    document.getElementById('pub-branch-search').focus();
    renderBranchList('');
  }
};

// Branch search filter
document.getElementById('pub-branch-search').oninput = (e) => {
  renderBranchList(e.target.value);
};

// Branch item selection
document.getElementById('pub-branch-list').onclick = (e) => {
  const item = e.target.closest('.pub-branch-item');
  if (!item) return;
  _pubSelectedBranch = item.dataset.branch;
  document.getElementById('pub-branch-display').textContent = _pubSelectedBranch;
  document.getElementById('pub-branch-dropdown').classList.remove('open');
  document.getElementById('pub-branch-arrow').classList.remove('open');
  renderBranchList('');
};

// Close branch dropdown when clicking outside
document.addEventListener('click', (e) => {
  if (!e.target.closest('.pub-branch-wrap')) {
    document.getElementById('pub-branch-dropdown').classList.remove('open');
    document.getElementById('pub-branch-arrow').classList.remove('open');
  }
  if (!e.target.closest('.pub-reviewers-wrap')) {
    document.getElementById('pub-member-dropdown').classList.remove('open');
  }
});

// Reviewer search — open dropdown and filter
document.getElementById('pub-reviewer-search').onfocus = () => {
  var hasMembers = (_pubMembersLoaded && _pubMembers.length > 0) || _pubSavedReviewers.length > 0;
  if (hasMembers) {
    document.getElementById('pub-member-dropdown').classList.add('open');
    renderMemberDropdown('');
  }
};
document.getElementById('pub-reviewer-search').oninput = (e) => {
  var hasMembers = (_pubMembersLoaded && _pubMembers.length > 0) || _pubSavedReviewers.length > 0;
  if (hasMembers) {
    document.getElementById('pub-member-dropdown').classList.add('open');
    renderMemberDropdown(e.target.value.trim());
  }
};
// Enter key = select first visible dropdown item, or manual add as fallback
document.getElementById('pub-reviewer-search').onkeydown = (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    // If dropdown is open and has a non-selected member, pick the first one
    var firstItem = document.querySelector('#pub-member-list .pub-member-item:not(.selected)');
    if (firstItem && document.getElementById('pub-member-dropdown').classList.contains('open')) {
      var uuid = firstItem.dataset.uuid;
      var inApi = _pubMembers.some(function(m) { return m.uuid === uuid; });
      if (inApi) {
        addReviewer(uuid);
      } else {
        var saved = _pubSavedReviewers.find(function(r) { return r.uuid === uuid; });
        if (saved && !_pubSelectedReviewers.some(function(r) { return r.uuid === uuid; })) {
          _pubSelectedReviewers.push({ displayName: saved.displayName, uuid: saved.uuid, nickname: saved.nickname });
          document.getElementById('pub-reviewer-search').value = '';
          renderReviewerChips();
          renderMemberDropdown('');
        }
      }
      document.getElementById('pub-member-dropdown').classList.remove('open');
    } else {
      addManualReviewer(e.target.value);
    }
  }
};
// "+" button = manual add
document.getElementById('pub-reviewer-add').onclick = () => {
  addManualReviewer(document.getElementById('pub-reviewer-search').value);
};

// Reviewer member selection + remove saved reviewer
document.getElementById('pub-member-list').onclick = (e) => {
  // Check if clicking the remove (x) button on a saved reviewer
  var removeBtn = e.target.closest('.pub-member-remove');
  if (removeBtn) {
    e.stopPropagation();
    var uuid = removeBtn.dataset.removeUuid;
    removeSavedReviewer(uuid);
    renderMemberDropdown(document.getElementById('pub-reviewer-search').value.trim());
    showToast('Saved reviewer removed');
    return;
  }
  var item = e.target.closest('.pub-member-item');
  if (!item || item.classList.contains('selected')) return;
  // Check if it's a saved reviewer (might not be in _pubMembers)
  var uuid = item.dataset.uuid;
  var inApi = _pubMembers.some(function(m) { return m.uuid === uuid; });
  if (inApi) {
    addReviewer(uuid);
  } else {
    // It's a saved reviewer — add directly
    var saved = _pubSavedReviewers.find(function(r) { return r.uuid === uuid; });
    if (saved && !_pubSelectedReviewers.some(function(r) { return r.uuid === uuid; })) {
      _pubSelectedReviewers.push({ displayName: saved.displayName, uuid: saved.uuid, nickname: saved.nickname });
      document.getElementById('pub-reviewer-search').value = '';
      renderReviewerChips();
      renderMemberDropdown('');
    }
  }
};

// Reviewer chip removal
document.getElementById('pub-reviewer-chips').onclick = (e) => {
  var x = e.target.closest('.pub-chip-x');
  if (!x) return;
  var chip = x.closest('.pub-reviewer-chip');
  if (chip) removeReviewer(chip.dataset.uuid);
};

// @Mention chip click
document.getElementById('pub-mention-row').onclick = (e) => {
  var chip = e.target.closest('.pub-mention-chip');
  if (chip) {
    insertMention(chip.dataset.nick);
    return;
  }
  var more = e.target.closest('.pub-mention-more');
  if (more) {
    // Show all members as mention chips
    var row = document.getElementById('pub-mention-row');
    var html = '<span class="pub-mention-label">Mention:</span>';
    for (var m of _pubMembers) {
      html += '<span class="pub-mention-chip" data-nick="' + m.nickname.replace(/"/g, '&quot;') + '">@' + m.nickname + '</span>';
    }
    row.innerHTML = html;
  }
};

// Code Compare modal open/close
document.getElementById('pub-open-diff').onclick = () => { openDiffModal(); };
document.getElementById('pub-diff-close').onclick = () => { closeDiffModal(); };
document.getElementById('pub-diff-overlay').onclick = (e) => {
  if (e.target === document.getElementById('pub-diff-overlay')) closeDiffModal();
};

// Back button
document.getElementById('pub-back').onclick = () => {
  if (_pubStep === 2) pubShowStep(1);
};

// Next / Publish / Close button
document.getElementById('pub-next').onclick = () => {
  if (_pubStep === 1) {
    if (!pubValidateSettings()) return;
    if (pubBuildReview() === false) return;
    pubShowStep(2);
  } else if (_pubStep === 2) {
    pubShowStep(3);
    pubRunPublish();
  } else if (_pubStep === 4) {
    closePublishModal();
  }
};

// ── Credential load handler (from code.js) ──
// Added to the window.onmessage handler below

function showToast(text) {
  const toast = document.getElementById('toast');
  toast.textContent = text;
  toast.classList.add('visible');
  setTimeout(() => toast.classList.remove('visible'), 2000);
}

// ═══════════════════════════════════════
// MINI MODE + LIVE SYNC
// ═══════════════════════════════════════

let isMinimized = false;
let isDocLive = false;

document.getElementById('btn-minimize').onclick = () => {
  isMinimized = true;
  document.body.classList.add('minimized');
  updateMiniBar();
  parent.postMessage({ pluginMessage: { type: 'resize-ui', width: 280, height: 44 } }, '*');
};

document.getElementById('btn-expand').onclick = () => {
  isMinimized = false;
  document.body.classList.remove('minimized');
  parent.postMessage({ pluginMessage: { type: 'resize-ui', width: 640, height: 760 } }, '*');
};

function updateMiniBar() {
  const dot = document.getElementById('mini-dot');
  const label = document.getElementById('mini-label');
  if (isDocLive) {
    dot.classList.remove('inactive');
    label.textContent = 'Doc live';
  } else {
    dot.classList.add('inactive');
    label.textContent = 'No doc';
  }
}

// ── Pre-load last PR config so it's ready when the publish modal opens ──
parent.postMessage({ pluginMessage: { type: 'bb-get-config' } }, '*');

</script>
</body>
</html>
